# A0146789H
###### /java/seedu/task/commons/util/HttpUtilTest.java
``` java

package seedu.task.commons.util;

import static org.junit.Assert.assertFalse;

import org.junit.Test;

public class HttpUtilTest {

    @Test
    public void httputil_invalidUrl_failure() {
        boolean result = HttpUtil.uploadFile("http://completelynonexistenturl123.xyz", "storage",
                "./src/test/java/seedu/task/commons/util/HttpUtilTest.java");
        assertFalse(result);
    }
}
```
###### /java/seedu/task/commons/util/NattyDateUtilTest.java
``` java
public class NattyDateUtilTest {

    /**
     * Checks if the date object passed in passes the expected inferred time object values.
     *
     * @param cal
     * @return true if the Calendar object matches the expected time for an inferred time object
     */
    public boolean nattyutil_inferredTimeTester(Date toTest) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(toTest);
        if (cal.get(Calendar.HOUR_OF_DAY) != 12) {
            return false;
        }
        if (cal.get(Calendar.MINUTE) != 0) {
            return false;
        }
        if (cal.get(Calendar.SECOND) != 0) {
            return false;
        }
        if (cal.get(Calendar.MILLISECOND) != 0) {
            return false;
        }
        return true;
    }

    public boolean nattyutil_relativeTimeTester(Date toTest, int daysOffset) {
        Calendar cal = Calendar.getInstance();
        Calendar tomorrow = Calendar.getInstance();
        tomorrow.add(Calendar.DATE, daysOffset);
        cal.setTime(toTest);
        if (!nattyutil_inferredTimeTester(toTest)) {
            return false;
        }
        // January is 0
        if (cal.get(Calendar.MONTH) != cal.get(Calendar.MONTH)) {
            return false;
        }
        if (cal.get(Calendar.DAY_OF_MONTH) != cal.get(Calendar.DAY_OF_MONTH)) {
            return false;
        }
        if (cal.get(Calendar.YEAR) != cal.get(Calendar.YEAR)) {
            return false;
        }
        return true;
    }

    /**
     *  Parses a simple date string in the Singaporean time format
     */
    @Test
    public void nattyutil_basicDate() {
        Date date = NattyDateUtil.parseSingleDate("10/03/17");
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        assertTrue(cal.get(Calendar.MONTH) == 2); // January is 0
        assertTrue(cal.get(Calendar.DAY_OF_MONTH) == 10);
        assertTrue(cal.get(Calendar.YEAR) == 2017);
    }

    /**
     *  Parses a relative time (tomorrow)
     */
    @Test
    public void nattyutil_tomorrow() {
        Date date = NattyDateUtil.parseSingleDate("tomorrow");
        assertTrue(nattyutil_relativeTimeTester(date, 1));
    }

    /**
     *  Parses a relative time (tomorrow) in shorthand
     */
    @Test
    public void nattyutil_tomorrowShorthand() {
        Date date = NattyDateUtil.parseSingleDate("tmr");
        assertTrue(nattyutil_relativeTimeTester(date, 1));
    }

    /**
     *  Parses a relative time (tomorrow) in alternative forms
     */
    @Test
    public void nattyutil_tomorrowAlternative() {
        Date date = NattyDateUtil.parseSingleDate("the next day");
        assertTrue(nattyutil_relativeTimeTester(date, 1));
    }

    /**
     *  Parses a relative time (next week)
     */
    @Test
    public void nattyutil_nextWeek() {
        Date date = NattyDateUtil.parseSingleDate("next week");
        assertTrue(nattyutil_relativeTimeTester(date, 7));
    }

    /**
     *  Parses a relative time (next year)
     */
    @Test
    public void nattyutil_nextYear() {
        Date date = NattyDateUtil.parseSingleDate("next year");
        assertTrue(nattyutil_relativeTimeTester(date, 365));
    }
}
```
###### /java/seedu/task/logic/LogicManagerTest.java
``` java
        /**
         * Generates a valid Task using the given seed.
         * Running this function with the same parameter values guarantees the returned Task will have the same state.
         * Each unique seed will generate a unique Task object.
         *
         * @param seed used to generate the Task data field values
         */
        Task generateTask(int seed) throws Exception {
            return new Task(
                    new Name("Task " + seed),
                    new StartTime(NattyDateUtil.parseSingleDate("12/11/11 0909")),
                    new EndTime(NattyDateUtil.parseSingleDate("12/11/11 0909")),
                    new CompletionStatus(false),
                    new UniqueTagList(new Tag("tag" + Math.abs(seed)), new Tag("tag" + Math.abs(seed + 1)))
                    );
        }

        /** Generates the correct add command based on the Task given */
        String generateAddCommand(Task p) {
            StringBuffer cmd = new StringBuffer();

            cmd.append("add ");

            cmd.append(p.getName().toString());
            cmd.append(" from ").append(p.getEndTime());
            cmd.append(" to ").append(p.getStartTime());

            UniqueTagList tags = p.getTags();
            for (Tag t: tags) {
                cmd.append(" #").append(t.tagName);
            }

            return cmd.toString();
        }

```
###### /java/seedu/task/logic/parser/ParserAddTagsTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.AddTagCommand;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class ParserAddTagsTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */
    @Test
    public void parser_addTags_noIndexTags() {
        Command result = this.parser.parseCommand("addtag");
        assertTrue(result instanceof IncorrectCommand);
    }

    @Test
    public void parser_addTags_noIndex() {
        Command result = this.parser.parseCommand("addtag #one");
        assertTrue(result instanceof IncorrectCommand);
    }

    /* Valid Tests
     *
     */

    @Test
    public void parser_addTags_oneTag() {
        String commandString = "addtag 5 #one";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof AddTagCommand);
    }

    @Test
    public void parser_addTags_noTags() {
        Command result = this.parser.parseCommand("addtag 1");
        assertTrue(result instanceof AddTagCommand);
    }
}
```
###### /java/seedu/task/logic/parser/ParserAddTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.AddCommand;
import seedu.task.logic.commands.Command;
import seedu.task.model.UndoManager;
import seedu.task.model.task.Name;
import seedu.task.model.task.Task;

public class ParserAddTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */


    /* Valid Tests
     *
     */

    // Add Command Tests

    @Test
    public void parser_add_floatingTask() {
        String commandString = "add Test Task";
        Command result = this.parser.parseCommand(commandString);

        // Check that the AddCommand is parsed properly
        assertTrue(result instanceof AddCommand);

        AddCommand added = (AddCommand) result;
        Task toAdd = added.getToAdd();

        // Check the description
        Name name = toAdd.getName();
        assertTrue(name.fullName.equals("Test Task"));
    }
}
```
###### /java/seedu/task/logic/parser/ParserCheckTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.CheckCommand;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class ParserCheckTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */
    @Test
    public void parser_check_noIndex() {
        Command result = this.parser.parseCommand("check");
        assertTrue(result instanceof IncorrectCommand);
    }


    /* Valid Tests
     *
     */

    @Test
    public void parser_check_Index() {
        String commandString = "check 5";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof CheckCommand);
    }

}
```
###### /java/seedu/task/logic/parser/ParserClearTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.ClearCommand;
import seedu.task.logic.commands.Command;
import seedu.task.model.UndoManager;

public class ParserClearTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */

    /* Valid Tests
     *
     */

    @Test
    public void parser_clear_noArgs() {
        String commandString = "clear";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof ClearCommand);
    }

}
```
###### /java/seedu/task/logic/parser/ParserCommonTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class ParserCommonTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */

    @Test
    public void parser_emptyInput() {
        Command result = this.parser.parseCommand("");
        assertTrue(result instanceof IncorrectCommand);
    }

    /* Valid Tests
     *
     */

}
```
###### /java/seedu/task/logic/parser/ParserDeleteTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.DeleteCommand;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class ParserDeleteTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */
    @Test
    public void parser_delete_noIndex() {
        String commandString = "delete";
        Command result = this.parser.parseCommand(commandString);

        // Check that the DeleteCommand is not able to be  parsed properly
        assertTrue(result instanceof IncorrectCommand);
    }

    /* Valid Tests
     *
     */

    // Add Command Tests

    @Test
    public void parser_delete_index() {
        String commandString = "delete 1";
        Command result = this.parser.parseCommand(commandString);

        // Check that the DeleteCommand is parsed properly
        assertTrue(result instanceof DeleteCommand);

        DeleteCommand deleted = (DeleteCommand) result;

        // Check the description
        int index = deleted.targetIndex;
        assertTrue(index == 1);
    }

}
```
###### /java/seedu/task/logic/parser/ParserDelTagsTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class ParserDelTagsTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */
    @Test
    public void parser_delTags_noIndexTags() {
        Command result = this.parser.parseCommand("deltag");
        assertTrue(result instanceof IncorrectCommand);
    }

    @Test
    public void parser_delTags_noIndex() {
        Command result = this.parser.parseCommand("deltag #one");
        assertTrue(result instanceof IncorrectCommand);
    }

    /* Valid Tests
     *
     */

    @Test
    public void parser_delTags_oneTag() {
        String commandString = "deltag 5 #one";
        Command result = this.parser.parseCommand(commandString);
        assertTrue(result != null);
        //TODO: Fix
        //assertTrue(result instanceof AddTagCommand);
    }

    @Test
    public void parser_addTags_noTags() {
        Command result = this.parser.parseCommand("deltag 1");
        assertTrue(result != null);
        //TODO: Fix
        //assertTrue(result instanceof AddTagCommand);
    }
}
```
###### /java/seedu/task/logic/parser/ParserEditTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Set;

import org.junit.Before;
import org.junit.Test;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.commons.util.NattyDateUtil;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.EditCommand;
import seedu.task.logic.commands.EditCommand.EditTaskDescriptor;
import seedu.task.model.UndoManager;
import seedu.task.model.tag.Tag;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.task.EndTime;
import seedu.task.model.task.StartTime;

public class ParserEditTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */

    /* Valid Tests
     *
     */

    // Edit Command Tests

    @Test
    public void parser_edit_description() {
        String commandString = "edit 2 buy groceries";

        Command result = this.parser.parseCommand(commandString);

        // Check that the EditCommand is parsed properly
        assertTrue(result instanceof EditCommand);
        EditCommand toEdit = (EditCommand) result;
        EditTaskDescriptor taskDescriptor = toEdit.getEditTaskDescriptor();

        // Check that the proper fields are set
        assertTrue(taskDescriptor.getName().isPresent());
        assertTrue(taskDescriptor.getName().get().fullName.equals("buy groceries"));
        assertFalse(taskDescriptor.getStartTime().isPresent());
        assertFalse(taskDescriptor.getEndTime().isPresent());
        assertFalse(taskDescriptor.getCompletionStatus().isPresent());
        assertFalse(taskDescriptor.getTags().isPresent());
    }

    @Test
    public void parser_edit_descriptionDeadline() {
        String commandString = "edit 2 buy groceries by 05/13/17";
        EndTime compareEndTime = null;

        try {
            compareEndTime = new EndTime(NattyDateUtil.parseSingleDate("05/13/17"));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        Command result = this.parser.parseCommand(commandString);

        // Check that the EditCommand is parsed properly
        assertTrue(result instanceof EditCommand);
        EditCommand toEdit = (EditCommand) result;
        EditTaskDescriptor taskDescriptor = toEdit.getEditTaskDescriptor();

        // Check that the proper fields are set
        assertTrue(taskDescriptor.getName().isPresent());
        assertTrue(taskDescriptor.getName().get().fullName.equals("buy groceries"));
        assertFalse(taskDescriptor.getStartTime().isPresent());
        assertTrue(taskDescriptor.getEndTime().isPresent());
        assertTrue(taskDescriptor.getEndTime().get().equals(compareEndTime));
        assertFalse(taskDescriptor.getCompletionStatus().isPresent());
        assertFalse(taskDescriptor.getTags().isPresent());
    }

    @Test
    public void parser_edit_descriptionDeadlineWithQuotes() {
        String commandString = "edit 2 '' by 05/13/17";
        EndTime compareEndTime = null;

        try {
            compareEndTime = new EndTime(NattyDateUtil.parseSingleDate("05/13/17"));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        Command result = this.parser.parseCommand(commandString);

        // Check that the EditCommand is parsed properly
        assertTrue(result instanceof EditCommand);
        EditCommand toEdit = (EditCommand) result;
        EditTaskDescriptor taskDescriptor = toEdit.getEditTaskDescriptor();

        // Check that the proper fields are set
        assertFalse(taskDescriptor.getName().isPresent());
        assertFalse(taskDescriptor.getStartTime().isPresent());
        assertTrue(taskDescriptor.getEndTime().isPresent());
        assertTrue(taskDescriptor.getEndTime().get().equals(compareEndTime));
        assertFalse(taskDescriptor.getCompletionStatus().isPresent());
        assertFalse(taskDescriptor.getTags().isPresent());
    }
    @Test
    public void parser_edit_tags() {
        String commandString = "edit 2 #first #second";

        Command result = this.parser.parseCommand(commandString);

        // Check that the EditCommand is parsed properly
        assertTrue(result instanceof EditCommand);
        EditCommand toEdit = (EditCommand) result;
        EditTaskDescriptor taskDescriptor = toEdit.getEditTaskDescriptor();

        // Check that the proper fields are set
        assertFalse(taskDescriptor.getName().isPresent());
        assertFalse(taskDescriptor.getStartTime().isPresent());
        assertFalse(taskDescriptor.getEndTime().isPresent());
        assertFalse(taskDescriptor.getCompletionStatus().isPresent());
        assertTrue(taskDescriptor.getTags().isPresent());

        // Check tags
        UniqueTagList tags = taskDescriptor.getTags().get();
        Set<Tag> tagSet = tags.toSet();
        assertTrue(tagSet.size() == 2);
        try {
            assertTrue(tagSet.contains(new Tag("first")));
            assertTrue(tagSet.contains(new Tag("second")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void parser_edit_descriptionComplete() {
        String commandString = "edit 2 buy groceries from 05/13/17 to 05/14/17 #first #second";
        StartTime compareStartTime = null;
        EndTime compareEndTime = null;

        try {
            compareStartTime = new StartTime(NattyDateUtil.parseSingleDate("05/13/17"));
            compareEndTime = new EndTime(NattyDateUtil.parseSingleDate("05/14/17"));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        Command result = this.parser.parseCommand(commandString);

        // Check that the EditCommand is parsed properly
        assertTrue(result instanceof EditCommand);
        EditCommand toEdit = (EditCommand) result;
        EditTaskDescriptor taskDescriptor = toEdit.getEditTaskDescriptor();

        // Check that the proper fields are set
        assertTrue(taskDescriptor.getName().isPresent());
        assertTrue(taskDescriptor.getName().get().fullName.equals("buy groceries"));
        assertTrue(taskDescriptor.getStartTime().isPresent());
        assertTrue(taskDescriptor.getStartTime().get().equals(compareStartTime));
        assertTrue(taskDescriptor.getEndTime().isPresent());
        assertTrue(taskDescriptor.getEndTime().get().equals(compareEndTime));
        assertFalse(taskDescriptor.getCompletionStatus().isPresent());
        assertTrue(taskDescriptor.getTags().isPresent());

        // Check tags
        UniqueTagList tags = taskDescriptor.getTags().get();
        Set<Tag> tagSet = tags.toSet();
        assertTrue(tagSet.size() == 2);
        try {
            assertTrue(tagSet.contains(new Tag("first")));
            assertTrue(tagSet.contains(new Tag("second")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
    }
}
```
###### /java/seedu/task/logic/parser/ParserEmailTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.EmailCommand;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class ParserEmailTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */
    @Test
    public void parser_emailInvalid_failure() {
        String commandString = "email notanemail";
        Command result = this.parser.parseCommand(commandString);
        assertTrue(result instanceof IncorrectCommand);
    }


    /* Valid Tests
     *
     */

    @Test
    public void parser_emailValid_successful() {
        String commandString = "email e0011018@u.nus.edu";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof EmailCommand);
    }

}
```
###### /java/seedu/task/logic/parser/ParserExitTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ExitCommand;
import seedu.task.model.UndoManager;

public class ParserExitTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */

    /* Valid Tests
     *
     */

    @Test
    public void parser_exit_noArgs() {
        String commandString = "exit";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof ExitCommand);
    }

}
```
###### /java/seedu/task/logic/parser/ParserHelpTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.HelpCommand;
import seedu.task.model.UndoManager;

public class ParserHelpTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */

    /* Valid Tests
     *
     */

    @Test
    public void parser_exit_noArgs() {
        String commandString = "help";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof HelpCommand);
    }

}
```
###### /java/seedu/task/logic/parser/ParserRedoTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.RedoCommand;
import seedu.task.model.UndoManager;

public class ParserRedoTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */

    /* Valid Tests
     *
     */

    @Test
    public void parser_redo_noArgs() {
        String commandString = "redo";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof RedoCommand);
    }

}
```
###### /java/seedu/task/logic/parser/ParserReminderTimeTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.ReminderTimeCommand;
import seedu.task.model.UndoManager;

public class ParserReminderTimeTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */
    @Test
    public void parser_timeInvalid_failure() {
        String commandString = "remindme a";
        Command result = this.parser.parseCommand(commandString);
        assertTrue(result instanceof IncorrectCommand);
    }

    @Test
    public void parser_timeNegative_failure() {
        String commandString = "remindme -4";
        Command result = this.parser.parseCommand(commandString);
        assertTrue(result instanceof IncorrectCommand);
    }

    /* Valid Tests
     *
     */

    @Test
    public void parser_timeValid_successful() {
        String commandString = "remindme 10";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof ReminderTimeCommand);
    }

}
```
###### /java/seedu/task/logic/parser/ParserUncheckTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.UncheckCommand;
import seedu.task.model.UndoManager;

public class ParserUncheckTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */
    @Test
    public void parser_uncheck_noIndex() {
        Command result = this.parser.parseCommand("uncheck");
        assertTrue(result instanceof IncorrectCommand);
    }


    /* Valid Tests
     *
     */

    @Test
    public void parser_uncheck_Index() {
        String commandString = "uncheck 5";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof UncheckCommand);
    }

}
```
###### /java/seedu/task/logic/parser/ParserUndoTest.java
``` java
package seedu.task.logic.parser;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.UndoCommand;
import seedu.task.model.UndoManager;

public class ParserUndoTest {
    private Parser parser;
    @SuppressWarnings("unused")
    private UndoManager undomanager;

    // Set up the fixtures
    @Before
    public void setUp() {
        this.parser = new Parser();
        // Initialize the UndoManager as well to create a previous command stack
        this.undomanager = new UndoManager();
    }

    /* Invalid Tests
     *
     */

    /* Valid Tests
     *
     */

    @Test
    public void parser_undo_noArgs() {
        String commandString = "undo";
        Command result = this.parser.parseCommand(commandString);

        assertTrue(result instanceof UndoCommand);
    }

}
```
###### /java/seedu/task/storage/JsonUserPrefsStorageTest.java
``` java

package seedu.task.storage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

import java.io.File;
import java.io.IOException;
import java.util.Optional;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.rules.TemporaryFolder;

import seedu.task.commons.exceptions.DataConversionException;
import seedu.task.commons.util.FileUtil;
import seedu.task.model.UserPrefs;

public class JsonUserPrefsStorageTest {

    private static final String TEST_DATA_FOLDER = FileUtil.getPath("./src/test/data/JsonUserPrefsStorageTest/");

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Rule
    public TemporaryFolder testFolder = new TemporaryFolder();

    @Test
    public void readUserPrefs_nullFilePath_assertionFailure() throws DataConversionException {
        thrown.expect(AssertionError.class);
        readUserPrefs(null);
    }

    private Optional<UserPrefs> readUserPrefs(String userPrefsFileInTestDataFolder) throws DataConversionException {
        String prefsFilePath = addToTestDataPathIfNotNull(userPrefsFileInTestDataFolder);
        return new JsonUserPrefsStorage(prefsFilePath).readUserPrefs(prefsFilePath);
    }

    @Test
    public void readUserPrefs_missingFile_emptyResult() throws DataConversionException {
        assertFalse(readUserPrefs("NonExistentFile.json").isPresent());
    }

    @Test
    public void readUserPrefs_notJsonFormat_exceptionThrown() throws DataConversionException {
        thrown.expect(DataConversionException.class);
        readUserPrefs("NotJsonFormatUserPrefs.json");

        /* IMPORTANT: Any code below an exception-throwing line (like the one above) will be ignored.
         * That means you should not have more than one exception test in one method
         */
    }

    private String addToTestDataPathIfNotNull(String userPrefsFileInTestDataFolder) {
        return userPrefsFileInTestDataFolder != null
                ? TEST_DATA_FOLDER + userPrefsFileInTestDataFolder
                        : null;
    }

    @Test
    public void readUserPrefs_fileInOrder_successfullyRead() throws DataConversionException {
        UserPrefs expected = new UserPrefs();
        expected.setGuiSettings(1000, 500, 300, 100);
        expected.setReminderEmail("");
        expected.setReminderTime(5);
        UserPrefs actual = readUserPrefs("TypicalUserPref.json").get();
        assertEquals(expected, actual);
    }

    @Test
    public void readUserPrefs_valuesMissingFromFile_defaultValuesUsed() throws DataConversionException {
        UserPrefs actual = readUserPrefs("EmptyUserPrefs.json").get();
        assertEquals(new UserPrefs(), actual);
    }

    @Test
    public void readUserPrefs_extraValuesInFile_extraValuesIgnored() throws DataConversionException {
        UserPrefs expected = new UserPrefs();
        expected.setGuiSettings(1000, 500, 300, 100);
        UserPrefs actual = readUserPrefs("ExtraValuesUserPref.json").get();

        assertEquals(expected, actual);
    }

    @Test
    public void savePrefs_nullPrefs_assertionFailure() throws IOException {
        thrown.expect(AssertionError.class);
        saveUserPrefs(null, "SomeFile.json");
    }

    @Test
    public void saveUserPrefs_nullFilePath_assertionFailure() throws IOException {
        thrown.expect(AssertionError.class);
        saveUserPrefs(new UserPrefs(), null);
    }

    private void saveUserPrefs(UserPrefs userPrefs, String prefsFileInTestDataFolder) throws IOException {
        new JsonUserPrefsStorage(addToTestDataPathIfNotNull(prefsFileInTestDataFolder)).saveUserPrefs(userPrefs);
    }

    @Test
    public void saveUserPrefs_allInOrder_success() throws DataConversionException, IOException {

        UserPrefs original = new UserPrefs();
        original.setGuiSettings(1200, 200, 0, 2);

        String pefsFilePath = testFolder.getRoot() + File.separator + "TempPrefs.json";
        JsonUserPrefsStorage jsonUserPrefsStorage = new JsonUserPrefsStorage(pefsFilePath);

        //Try writing when the file doesn't exist
        jsonUserPrefsStorage.saveUserPrefs(original);
        UserPrefs readBack = jsonUserPrefsStorage.readUserPrefs().get();
        assertEquals(original, readBack);

        //Try saving when the file exists
        original.setGuiSettings(5, 5, 5, 5);
        jsonUserPrefsStorage.saveUserPrefs(original);
        readBack = jsonUserPrefsStorage.readUserPrefs().get();
        assertEquals(original, readBack);
    }

}
```
###### /java/seedu/task/testutil/TestTask.java
``` java
/**
 * A mutable task object. For testing only.
 */
public class TestTask implements ReadOnlyTask {

    private Name name;
    private CompletionStatus completionStatus;
    private StartTime startTime;
    private EndTime endTime;
    private TaskType taskType;
    private UniqueTagList tags;

    public TestTask() {
        tags = new UniqueTagList();
    }

    /**
     * Creates a copy of {@code personToCopy}.
     */
    public TestTask(TestTask taskToCopy) {
        this.name = taskToCopy.getName();
        this.startTime = taskToCopy.getStartTime();
        this.endTime = taskToCopy.getEndTime();
        this.completionStatus = taskToCopy.getCompletionStatus();
        this.tags = taskToCopy.getTags();
        this.taskType = taskToCopy.getTaskType();
    }

    public TestTask(Task taskToCopy) {
        this.name = taskToCopy.getName();
        this.startTime = taskToCopy.getStartTime();
        this.endTime = taskToCopy.getEndTime();
        this.completionStatus = taskToCopy.getCompletionStatus();
        this.tags = taskToCopy.getTags();
        this.taskType = taskToCopy.getTaskType();
    }

    public void setName(Name name) {
        this.name = name;
    }

    public void setCompletionStatus(CompletionStatus completionStatus) {
        this.completionStatus = completionStatus;
    }

    public void setEndTime(EndTime endTime) {
        this.endTime = endTime;
    }

    public void setStartTime(StartTime startTime) {
        this.startTime = startTime;
    }

    public void setTags(UniqueTagList tags) {
        this.tags = tags;
    }

    public void setTaskType(TaskType taskType) {
        this.taskType = taskType;
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public StartTime getStartTime() {
        return startTime;
    }

    @Override
    public EndTime getEndTime() {
        return endTime;
    }

    @Override
    public CompletionStatus getCompletionStatus() {
        return completionStatus;
    }

    @Override
    public UniqueTagList getTags() {
        return tags;
    }

    @Override
    public String toString() {
        return getAsText();
    }

    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + this.getName().fullName + " ");
        sb.append(" from " + this.getStartTime().value + " ");
        sb.append(" to " + this.getEndTime().value + " ");
        this.getTags().asObservableList().stream().forEach(s -> sb.append(" #" + s.tagName + " "));
        return sb.toString();
    }

    @Override
    public TaskType getTaskType() {
        return taskType;
    }
}
```
###### /java/seedu/task/testutil/TestTaskBuilder.java
``` java
/**
 * Builds a test task.
 */
public class TestTaskBuilder {

    private TestTask task;

    public TestTaskBuilder() {
        this.task = new TestTask();
    }

    /**
     * Initializes the PersonBuilder with the data of {@code personToCopy}.
     */
    public TestTaskBuilder(TestTask taskToCopy) {
        this.task = new TestTask(taskToCopy);
    }
    public TestTaskBuilder(Task taskToCopy) {
        this.task = new TestTask(taskToCopy);
    }

    public TestTaskBuilder withName(String name) throws IllegalValueException {
        this.task.setName(new Name(name));
        return this;
    }

    public TestTaskBuilder withTags(String ... tags) throws IllegalValueException {
        task.setTags(new UniqueTagList());
        for (String tag: tags) {
            task.getTags().add(new Tag(tag));
        }
        return this;
    }

```
###### /java/seedu/task/testutil/TestTaskBuilder.java
``` java
    public TestTaskBuilder withStartDate(String dateString) throws IllegalValueException {
        this.task.setStartTime(new StartTime(NattyDateUtil.parseSingleDate(dateString)));
        return this;
    }

    public TestTaskBuilder withEndDate(String email) throws IllegalValueException {
        this.task.setEndTime(new EndTime(NattyDateUtil.parseSingleDate(email)));
        return this;
    }

    public TestTask build() {
        return this.task;
    }

}
```
###### /java/seedu/task/testutil/TestUtil.java
``` java
    private static Task[] getSampleTaskData() {
        try {
            StartTime sampleStartTime = new StartTime(NattyDateUtil.parseSingleDate("06/13/13 0909"));
            EndTime sampleEndTime = new EndTime(NattyDateUtil.parseSingleDate("06/13/13 0909"));
            //CHECKSTYLE.OFF: LineLength
            return new Task[]{
                new Task(new Name("Task 1"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList()),
                new Task(new Name("Task 2"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList()),
                new Task(new Name("Task 3"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList()),
                new Task(new Name("Task 4"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList()),
                new Task(new Name("Task 5"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList()),
                new Task(new Name("Task 6"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList()),
                new Task(new Name("Task 7"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList()),
                new Task(new Name("Task 8"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList()),
                new Task(new Name("Task 9"), sampleStartTime, sampleEndTime, new CompletionStatus(false), new UniqueTagList())
            };
            //CHECKSTYLE.ON: LineLength
        } catch (IllegalValueException e) {
            assert false;
            // not possible
            return null;
        }
    }

```
