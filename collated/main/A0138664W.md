# A0138664W
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
    public CommandResult executeUndo(Task previousTask, Model model) throws CommandException {
        try {
            model.addTaskUndo(previousTask);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getTaskID(previousTask)));
            return new CommandResult(String.format(UndoCommand.MESSAGE_UNDO_SUCCESS_ADD, previousTask));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

    }

    public CommandResult executeRedo(Task previousTask, Model model) throws CommandException {
        try {
            model.addTaskUndo(previousTask);
            return new CommandResult(String.format(RedoCommand.MESSAGE_REDO_SUCCESS_ADD, previousTask));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

    }

```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
package seedu.task.logic.commands;

import java.util.List;
import java.util.Set;

import seedu.task.commons.core.EventsCenter;
import seedu.task.commons.core.Messages;
import seedu.task.commons.events.ui.JumpToListRequestEvent;
import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.Model;
import seedu.task.model.tag.Tag;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.tag.UniqueTagList.DuplicateTagException;
import seedu.task.model.task.CompletionStatus;
import seedu.task.model.task.EndTime;
import seedu.task.model.task.Name;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.StartTime;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList;

public class AddTagCommand extends Command {

```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Adds tags to existing task.\n"
            + "Parameters: INDEX [#tag]\n"
            + "Example: " + DEFACTO_COMMAND
            + " 1 #CS2103 #uni";
    public static final String ADD_TAG_SUCCESS = "I have added new tags into task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "Sorry, this task already "
            + "exists in the task manager.";
    public static final String MESSAGE_DUPLICATE_TAGS = "Sorry, this task already has this tag.";


    private int filteredTaskListIndex;
    private Set<String> tags;

```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
    public AddTagCommand(int filteredTaskListIndex, Set<String> tags) throws IllegalValueException {
        this();
        assert tags != null;
        assert filteredTaskListIndex > 0;
        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.tags = tags;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task taskEdited = (Task) taskToEdit;
        Task editedTask = null;

        try {
            editedTask = createTaskAfterAddedTags(taskToEdit, tags);
        } catch (DuplicateTagException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TAGS);
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        try {
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getTaskID(taskEdited)));
        return new CommandResult(String.format(ADD_TAG_SUCCESS, editedTask));
    }

    public CommandResult executeUndo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(taskID));
        return new CommandResult(String.format(UndoCommand.MESSAGE_UNDO_SUCCESS_EDIT, previousTask));
    }

    public CommandResult executeRedo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(RedoCommand.MESSAGE_REDO_SUCCESS_EDIT, previousTask));
    }

    private static Task createTaskAfterAddedTags(ReadOnlyTask taskToEdit, Set<String> tags)
           throws DuplicateTagException, IllegalValueException {
        assert taskToEdit != null;

        Name name = taskToEdit.getName();
        StartTime startTime = taskToEdit.getStartTime();
        EndTime endTime = taskToEdit.getEndTime();
        CompletionStatus updatedCompletionStatus = taskToEdit.getCompletionStatus();

        UniqueTagList tagList = taskToEdit.getTags();

        for (String tagName: tags) {
            tagList.add(new Tag(tagName));
        }

        return new Task(name, startTime, endTime, updatedCompletionStatus, tagList);
    }

```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
package seedu.task.logic.commands;

import java.util.List;

import seedu.task.commons.core.EventsCenter;
import seedu.task.commons.core.Messages;
import seedu.task.commons.events.ui.JumpToListRequestEvent;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.Model;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList;

public class CheckCommand extends TaskCompleted {

```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    public static final String MESSAGE_CHECK_SUCCESS = "Task %1$s has been checked/completed!";
    public static final String MESSAGE_TASK_ALREADY_CHECKED = "Sorry, Task %1$s is already checked.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    private int filteredTaskListIndex;

```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    public CheckCommand (int filteredTaskListIndex) {
        this();
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMarkComplete = lastShownList.get(filteredTaskListIndex);

        if (taskToMarkComplete.getCompletionStatus().getCompletion() == true) {
            throw new CommandException(String.format(MESSAGE_TASK_ALREADY_CHECKED, taskToMarkComplete.getName()));
        }

        Task completedTask = changeTaskCompletion(taskToMarkComplete);

        try {
            model.updateTask(filteredTaskListIndex, completedTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getTaskID(completedTask)));
        return new CommandResult(String.format(MESSAGE_CHECK_SUCCESS, taskToMarkComplete.getName()));
    }

```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    public CommandResult executeUndo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        previousTask = changeTaskCompletion(previousTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(taskID));
        return new CommandResult(String.format(UndoCommand.MESSAGE_UNDO_SUCCESS_CHECKED, previousTask));
    }

    public CommandResult executeRedo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        previousTask = changeTaskCompletion(previousTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(RedoCommand.MESSAGE_REDO_SUCCESS_CHECKED, previousTask));
    }

```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
    public CommandResult executeUndo(Task previousTask, Model model) throws CommandException {
        try {
            model.deleteTaskUndo(previousTask);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(UndoCommand.MESSAGE_UNDO_SUCCESS_DELETE, previousTask));
    }

    public CommandResult executeRedo(Task previousTask, Model model) throws CommandException {
        try {
            model.deleteTaskUndo(previousTask);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(RedoCommand.MESSAGE_REDO_SUCCESS_DELETE, previousTask));
    }

```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
package seedu.task.logic.commands;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import seedu.task.commons.core.EventsCenter;
import seedu.task.commons.core.Messages;
import seedu.task.commons.events.ui.JumpToListRequestEvent;
import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.Model;
import seedu.task.model.tag.Tag;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.task.CompletionStatus;
import seedu.task.model.task.EndTime;
import seedu.task.model.task.Name;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.StartTime;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList;

public class DeleteTagCommand extends Command {

```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Delete existing tags in existing task.\n"
            + "Parameters: INDEX [#tag]\n"
            + "Example: " + DEFACTO_COMMAND
            + " 1 #CS2103 #uni";
    public static final String DEL_TAG_SUCCESS = "I have deleted the tags from task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK =
            "Sorry, this task already exists in the task manager.";
    public static final String MESSAGE_DUPLICATE_TAGS = "This tag already exists in the task.";
    public static final String MESSAGE_TASK_WITHOUT_TAGS = "Sorry, this task has no tags to delete.";


    private int filteredTaskListIndex;
    private Set<String> tags;

```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
    public DeleteTagCommand(int filteredTaskListIndex, Set<String> tags) throws IllegalValueException {
        this();
        assert tags != null;
        assert filteredTaskListIndex > 0;
        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.tags = tags;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task taskEdited = (Task) taskToEdit;
        Task editedTask = createTaskAfterDeletedTags(taskToEdit, tags);

        try {
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getTaskID(taskEdited)));
        return new CommandResult(String.format(DEL_TAG_SUCCESS, editedTask));
    }

    public CommandResult executeUndo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(taskID));
        return new CommandResult(String.format(UndoCommand.MESSAGE_UNDO_SUCCESS_EDIT, previousTask));
    }

    public CommandResult executeRedo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(RedoCommand.MESSAGE_REDO_SUCCESS_EDIT, previousTask));
    }

    private static Task createTaskAfterDeletedTags(ReadOnlyTask taskToEdit, Set<String> tags) throws CommandException {
        assert taskToEdit != null;

        //current won't enter cause getTags will not equal null
        if (taskToEdit.getTags() == null) {
            throw new CommandException(MESSAGE_TASK_WITHOUT_TAGS);
        }

        Name name = taskToEdit.getName();
        StartTime startTime = taskToEdit.getStartTime();
        EndTime endTime = taskToEdit.getEndTime();
        CompletionStatus updatedCompletionStatus = taskToEdit.getCompletionStatus();

        UniqueTagList tagListToCheck = taskToEdit.getTags();
        Set<Tag> tagSet = new HashSet<>();
        for (Tag t : tagListToCheck) {
            tagSet.add(t);
        }

        for (Tag t : tagListToCheck) {
            for (String s : tags) {
                if (s.equals(t.getTagName())) {
                    tagSet.remove(t);
                }
            }
        }

        UniqueTagList newTagList = new UniqueTagList(tagSet);

        return new Task(name, startTime, endTime, updatedCompletionStatus, newTagList);
    }

```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
    public CommandResult executeUndo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        int newTaskID = model.getTaskID(previousTask);
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(newTaskID));
        return new CommandResult(String.format(UndoCommand.MESSAGE_UNDO_SUCCESS_EDIT, previousTask));
    }

    public CommandResult executeRedo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        int newTaskID = model.getTaskID(previousTask);
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(newTaskID));
        return new CommandResult(String.format(RedoCommand.MESSAGE_REDO_SUCCESS_EDIT, previousTask));
    }
```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.task.Task;

public class RedoCommand extends Command {
```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
    public static final String MESSAGE_USAGE = DEFACTO_COMMAND
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + DEFACTO_COMMAND + " 1";

    public static final String MESSAGE_REDO_SUCCESS_EDIT =
            "Redo Command Successful.\nRestored previously edited task: %1$s";
    public static final String MESSAGE_REDO_SUCCESS_ADD =
            "Redo Command Successful.\nRestored previously added task: %1$s";
    public static final String MESSAGE_REDO_SUCCESS_DELETE = "Redo Command Successful.\nDeleted task: %1$s";
    public static final String MESSAGE_REDO_SUCCESS_CHECKED = "Redo Command Successful.\nChecked task: %1$s";
    public static final String MESSAGE_REDO_SUCCESS_UNCHEKED = "Redo Command Successful.\nUncheked task: %1$s";
    public static final String MESSAGE_REDO_SUCCESS = "Redo Command Successful.";
    public static final String NOTHING_TO_REDO = "Nothing To Redo";

```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {

        if (model.getUndoManager().getRedoCommandHistoryStatus()) {
            return new CommandResult(NOTHING_TO_REDO);
        }

        String previousCommand = model.getUndoManager().popRedoCommand();

        if (model.getUndoManager().getRedoStackStatus()) {
            return new CommandResult(NOTHING_TO_REDO);
        }

        System.out.println(previousCommand);
        Task previousTask;
        Task editedTask;

        // TODO: This looks really ugly. Should fix this  Maybe use enums? - Jeremy
        if (previousCommand.equals(DeleteCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popRedoTask();
            return new DeleteCommand().executeRedo(previousTask, model);
        } else if (previousCommand.equals(AddCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popRedoTask();
            return new AddCommand().executeRedo(previousTask, model);
        } else if (previousCommand.equals(EditCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popRedoEditedTask();
            editedTask = model.getUndoManager().popRedoTask();
            return new EditCommand().executeRedo(previousTask, editedTask, model);
        } else if (previousCommand.equals(CheckCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popRedoEditedTask();
            editedTask = model.getUndoManager().popRedoTask();
            return new CheckCommand().executeUndo(previousTask, editedTask, model);
        } else if (previousCommand.equals(UncheckCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popRedoEditedTask();
            editedTask = model.getUndoManager().popRedoTask();
            return new UncheckCommand().executeUndo(previousTask, editedTask, model);
        } else if (previousCommand.equals(AddTagCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popRedoEditedTask();
            editedTask = model.getUndoManager().popRedoTask();
            return new AddTagCommand().executeRedo(previousTask, editedTask, model);
        } else if (previousCommand.equals(DeleteTagCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popRedoEditedTask();
            editedTask = model.getUndoManager().popRedoTask();
            return new DeleteTagCommand().executeRedo(previousTask, editedTask, model);
        } else {
            return new CommandResult(NOTHING_TO_REDO);
        }
    }

```
###### /java/seedu/task/logic/commands/TaskCompleted.java
``` java
package seedu.task.logic.commands;

import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.task.CompletionStatus;
import seedu.task.model.task.EndTime;
import seedu.task.model.task.Name;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.StartTime;
import seedu.task.model.task.Task;

public abstract class TaskCompleted extends Command {

```
###### /java/seedu/task/logic/commands/TaskCompleted.java
``` java
    @Override
    public abstract CommandResult execute() throws CommandException;

    public Task changeTaskCompletion (ReadOnlyTask taskToMarkComplete) {

        Name name = taskToMarkComplete.getName();
        StartTime startTime = taskToMarkComplete.getStartTime();
        EndTime endTime = taskToMarkComplete.getEndTime();
        UniqueTagList tagList = taskToMarkComplete.getTags();
        CompletionStatus updatedCompletionStatus = taskToMarkComplete.getCompletionStatus();
        updatedCompletionStatus.swapCompletion();

        return new Task(name, startTime, endTime, updatedCompletionStatus, tagList);
    }
}
```
###### /java/seedu/task/logic/commands/UncheckCommand.java
``` java
    public CommandResult executeUndo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        previousTask = changeTaskCompletion(previousTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(taskID));
        return new CommandResult(String.format(UndoCommand.MESSAGE_UNDO_SUCCESS_UNCHECKED, previousTask));
    }

    public CommandResult executeRedo(Task previousTask, Task editedTask, Model model) throws CommandException {
        int taskID = model.getTaskID(editedTask);
        previousTask = changeTaskCompletion(previousTask);
        try {
            model.updateTaskUndo(taskID, previousTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(RedoCommand.MESSAGE_REDO_SUCCESS_UNCHEKED, previousTask));
    }

```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.task.Task;

public class UndoCommand extends Command {
```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
    public static final String MESSAGE_USAGE = DEFACTO_COMMAND
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + DEFACTO_COMMAND + " 1";
    public static final String MESSAGE_UNDO_SUCCESS_EDIT =
            "Undo Command Successful.\nRestored previously edited task: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS_ADD =
            "Undo Command Successful.\nRestored previously added task: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS_DELETE = "Undo Command Successful.\nDeleted task: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS_CHECKED = "Undo Command Successful.\nChecked task: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS_UNCHECKED = "Undo Command Successful.\nUnchecked task: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS = "Undo Command Successful.";
    public static final String NOTHING_TO_UNDO = "Nothing To Undo";

```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {

        if (model.getUndoManager().getCommandHistoryStatus()) {
            return new CommandResult(NOTHING_TO_UNDO);
        }

        String previousCommand = model.getUndoManager().popUndoCommand();


        if (model.getUndoManager().getUndoStackStatus()) {
            return new CommandResult(NOTHING_TO_UNDO);
        }

        System.out.println(previousCommand);
        Task previousTask;
        Task editedTask;

       // TODO: This looks really ugly. Should fix this  Maybe use enums? - Jeremy
        if (previousCommand.equals(DeleteCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popUndoTask();
            return new AddCommand().executeUndo(previousTask, model);
        } else if (previousCommand.equals(AddCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popUndoTask();
            return new DeleteCommand().executeUndo(previousTask, model);
        } else if (previousCommand.equals(EditCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popUndoTask();
            editedTask = model.getUndoManager().popEditedTask();
            return new EditCommand().executeUndo(previousTask, editedTask, model);
        } else if (previousCommand.equals(CheckCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popUndoTask();
            editedTask = model.getUndoManager().popEditedTask();
            return new CheckCommand().executeUndo(previousTask, editedTask, model);
        } else if (previousCommand.equals(UncheckCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popUndoTask();
            editedTask = model.getUndoManager().popEditedTask();
            return new UncheckCommand().executeUndo(previousTask, editedTask, model);
        } else if (previousCommand.equals(AddTagCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popUndoTask();
            editedTask = model.getUndoManager().popEditedTask();
            return new DeleteTagCommand().executeUndo(previousTask, editedTask, model);
        } else if (previousCommand.equals(DeleteTagCommand.DEFACTO_COMMAND)) {
            previousTask = model.getUndoManager().popUndoTask();
            editedTask = model.getUndoManager().popEditedTask();
            return new AddTagCommand().executeUndo(previousTask, editedTask, model);
        } else {
            return new CommandResult(NOTHING_TO_UNDO);
        }
    }

```
###### /java/seedu/task/logic/parser/AddTagsParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.HashSet;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.commands.AddTagCommand;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class AddTagsParser extends AbstractParser {
    private static final String PATTERN_MANDATORY_INDEX = "(?<index>[1-9]\\d*)";
    private static final String PATTERN_OPTIONAL_TAGS = "(?<tags>(?:\\s+#\\w+)+)?";
    private static final String ARGUMENTS_PATTERN = "^" + PATTERN_MANDATORY_INDEX + PATTERN_OPTIONAL_TAGS + "$";
    private static final Pattern ARGUMENTS_FORMAT = Pattern.compile(ARGUMENTS_PATTERN, Pattern.CASE_INSENSITIVE);

    @Override
    public Command parse(String args) {

        assert args != null;

        int index;
        String tagsString;

        Set<String> tagSet = new HashSet<String>();

        try {
            // Extract the tokens from the argument string.
            final Matcher matcher = ARGUMENTS_FORMAT.matcher(args);
            if (!matcher.matches()) {
                throw new NoSuchElementException();
            }

            assert !args.isEmpty();
            index = ParserUtil.parseIndex(matcher.group("index")).get();
            tagsString = Optional.ofNullable(matcher.group("tags")).orElse("").trim();

            // Log tokens for debugging.
//            logger.info(String.format("%s taskName: '%s', startDateString: '%s', endDateString: '%s', tags: '%s'",
//                    logPrefix, taskName, startDateString, endDateString, tagsString));


            // Add each tag to the tag set.
            tagSet = ParserUtil.parseTagStringToSet(tagsString);

            // Log the tags
//            logger.info(String.format("%s tagSet: %s", logPrefix, tagSet.toString()));

            // Add the undo entry after successfully parsing an AddCommand
            UndoManager.pushUndoCommand(AddTagCommand.DEFACTO_COMMAND);

            return new AddTagCommand(index, tagSet);
        } catch (NoSuchElementException nsee) {
            // TODO: This needs to be changed to the default case of search.
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddTagCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### /java/seedu/task/logic/parser/CheckCommandParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.task.logic.commands.CheckCommand;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class CheckCommandParser extends AbstractParser {
    @Override
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CheckCommand.MESSAGE_USAGE));
        }

        // Add the undo entry after the CheckCommand is successfully parsed.
        UndoManager.pushUndoCommand(CheckCommand.DEFACTO_COMMAND);

        return new CheckCommand(index.get());
    }

```
###### /java/seedu/task/logic/parser/DeleteTagsParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.HashSet;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.DeleteTagCommand;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.model.UndoManager;

public class DeleteTagsParser extends AbstractParser {
    private static final String PATTERN_MANDATORY_INDEX = "(?<index>[1-9]\\d*)";
    private static final String PATTERN_OPTIONAL_TAGS = "(?<tags>(?:\\s+#\\w+)+)?";
    private static final String ARGUMENTS_PATTERN = "^" + PATTERN_MANDATORY_INDEX + PATTERN_OPTIONAL_TAGS + "$";
    private static final Pattern ARGUMENTS_FORMAT = Pattern.compile(ARGUMENTS_PATTERN, Pattern.CASE_INSENSITIVE);

    @Override
    public Command parse(String args) {

        assert args != null;

        int index;
        String tagsString;

        Set<String> tagSet = new HashSet<String>();

        try {
            // Extract the tokens from the argument string.
            final Matcher matcher = ARGUMENTS_FORMAT.matcher(args);
            if (!matcher.matches()) {
                throw new NoSuchElementException();
            }

            assert !args.isEmpty();
            index = ParserUtil.parseIndex(matcher.group("index")).get();
            tagsString = Optional.ofNullable(matcher.group("tags")).orElse("").trim();

            // Log tokens for debugging.
//            logger.info(String.format("%s taskName: '%s', startDateString: '%s', endDateString: '%s', tags: '%s'",
//                    logPrefix, taskName, startDateString, endDateString, tagsString));


            // Add each tag to the tag set.
            tagSet = ParserUtil.parseTagStringToSet(tagsString);

            // Log the tags
//            logger.info(String.format("%s tagSet: %s", logPrefix, tagSet.toString()));

            // Add the undo entry after successfully parsing an AddCommand
            UndoManager.pushUndoCommand(DeleteTagCommand.DEFACTO_COMMAND);

            return new DeleteTagCommand(index, tagSet);
        } catch (NoSuchElementException nsee) {
            // TODO: This needs to be changed to the default case of search.
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteTagCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### /java/seedu/task/logic/parser/UncheckCommandParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.UncheckCommand;
import seedu.task.model.UndoManager;

public class UncheckCommandParser extends AbstractParser {
    @Override
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UncheckCommand.MESSAGE_USAGE));
        }

        // Add the undo entry after the UncheckCommand is successfully parsed.
        UndoManager.pushUndoCommand(UncheckCommand.DEFACTO_COMMAND);

        return new UncheckCommand(index.get());
    }

```
###### /java/seedu/task/model/CommandStack.java
``` java
package seedu.task.model;

import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Stack;

public class CommandStack {
    private Stack<String> commandStack = new Stack<String>();
    private LinkedList<String> commandHistory = new LinkedList<String>();
    public ListIterator<String> commandHistoryIterator;

    public void pushCommand(String command) {
        commandStack.push(command);
    }

    public void addCommandHistory (String command) {
        commandHistory.addFirst(command);
        refreshIterator();
    }

    private void refreshIterator() {
        commandHistoryIterator = commandHistory.listIterator();
    }

    public String popCommand() {
        return commandStack.pop();
    }

    public boolean getCommandHistoryStatus() {
        return commandStack.empty();
    }
}
```
###### /java/seedu/task/model/Model.java
``` java
    void deleteTaskUndo(ReadOnlyTask target) throws TaskNotFoundException;

    void updateTaskUndo(int filteredTaskListIndex, ReadOnlyTask editedTask) throws DuplicateTaskException;

    void addTaskUndo(Task task) throws DuplicateTaskException;

    UndoManager getUndoManager();

```
###### /java/seedu/task/model/ModelManager.java
``` java
    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        taskManager.removeTask(target);
        Task deletedTask = new Task(target);
        undoManager.pushUndoTask(deletedTask);
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        taskManager.addTask(task);
        undoManager.pushUndoTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedTask != null;
        Task taskBackup = new Task(filteredTasks.get(filteredTaskListIndex));
        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.updateTask(taskManagerIndex, editedTask);
        undoManager.pushUndoTask(taskBackup);
        undoManager.pushEditedTask(new Task(editedTask));
        indicateTaskManagerChanged();
    }

```
###### /java/seedu/task/model/ModelManager.java
``` java
    @Override
    public synchronized void deleteTaskUndo(ReadOnlyTask target) throws TaskNotFoundException {
        taskManager.removeTask(target);
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void addTaskUndo(Task task) throws UniqueTaskList.DuplicateTaskException {
        taskManager.addTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public void updateTaskUndo(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedTask != null;
        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.updateTask(taskManagerIndex, editedTask);
        indicateTaskManagerChanged();
    }

    @Override
    public UndoManager getUndoManager() {
        return undoManager;
    }

    @Override
    public int getTaskID(Task task) {
        return taskManager.getTaskID(task);
    }
```
###### /java/seedu/task/model/tag/Tag.java
``` java
    public String getTagName() {
        return tagName;
    }
```
###### /java/seedu/task/model/task/UniqueTaskList.java
``` java
    @Override
    public int compare(Task task1, Task task2) {
        Date task1Date = task1.getEndTime().getValue();
        Date task2Date = task2.getEndTime().getValue();

        if (!task1.hasEndTime()) {
            if (!task2.hasEndTime()) {
                return 0;
            }
            return 1;
        } else if (task1.hasEndTime()) {
            if (!task2.hasEndTime()) {
                return -1;
            }
        }

        if (task1Date.after(task2Date)) {
            return 1;
        } else if (task1Date.before(task2Date)) {
            return -1;
        } else {
            return 0;
        }
    }

    Comparator<Task> checkUncheckComparator = new Comparator<Task>() {
        @Override
        public int compare(Task o1, Task o2) {
            if (o1.getCompletionStatus().getCompletion()) {
                if (o2.getCompletionStatus().getCompletion()) {
                    return 0;
                }
                return 1;
            } else if (!o1.getCompletionStatus().getCompletion()) {
                if (o2.getCompletionStatus().getCompletion()) {
                    return -1;
                }
            }
            return 0;
        }
    };
```
###### /java/seedu/task/model/UndoManager.java
``` java
package seedu.task.model;

import java.util.Stack;

import seedu.task.model.task.Task;

public class UndoManager {

    private Stack<Task> undoTaskStack;
    private Stack<Task> redoTaskStack;
    private Stack<Task> editedTaskStack;
    private Stack<Task> redoEditedTaskStack;
    private static CommandStack undoCommand;
    private static CommandStack redoCommand;

    public UndoManager() {
        undoTaskStack = new Stack<Task>();
        redoTaskStack = new Stack<Task>();
        editedTaskStack = new Stack<Task>();
        redoEditedTaskStack = new Stack<Task>();
        undoCommand = new CommandStack();
        redoCommand = new CommandStack();
    }

    public void pushUndoTask(Task task) {
        undoTaskStack.push(task);
    }

    public void pushRedoTask(Task task) {
        redoTaskStack.push(task);
    }

    public void pushEditedTask(Task task) {
        editedTaskStack.push(task);
    }

    public void pushRedoEditedTask(Task task) {
        redoEditedTaskStack.push(task);
    }

    public void pushRedoCommand(String command) {
        redoCommand.pushCommand(command);
    }

    public static void pushUndoCommand(String command) {
        undoCommand.pushCommand(command);
    }

    public Task popUndoTask () {
        Task task = undoTaskStack.pop();
        redoTaskStack.push(task);
        return task;
    }

    public Task popRedoTask() {
        Task task = redoTaskStack.pop();
        undoTaskStack.push(task);
        return task;
    }

    public String popUndoCommand() {
        String command = undoCommand.popCommand();
        redoCommand.pushCommand(command);
        return command;
    }

    public String popRedoCommand() {
        String command = redoCommand.popCommand();
        undoCommand.pushCommand(command);
        return command;
    }

    public Task popEditedTask() {
        Task task = editedTaskStack.pop();
        redoEditedTaskStack.push(task);
        return task;
    }

    public Task popRedoEditedTask() {
        Task task = redoEditedTaskStack.pop();
        editedTaskStack.push(task);
        return task;
    }

    public boolean getUndoStackStatus() {
        return undoTaskStack.empty();
    }

    public boolean getRedoStackStatus() {
        return redoTaskStack.empty();
    }

    public boolean getCommandHistoryStatus() {
        return undoCommand.getCommandHistoryStatus();
    }

    public boolean getRedoCommandHistoryStatus() {
        return redoCommand.getCommandHistoryStatus();
    }

}
```
###### /java/seedu/task/ui/CommandBox.java
``` java
    @FXML
    private void keyListener(KeyEvent key) {
        KeyCode keycode = key.getCode();

        if (keycode == KeyCode.UP || keycode == KeyCode.KP_UP) {
            getPreviousCommand();
            key.consume();
        } else if (keycode == KeyCode.DOWN || keycode == KeyCode.KP_DOWN) {
            getNextCommand();
            key.consume();
        }

    }

    private void getNextCommand() {
        if (commandHistory.commandHistoryIterator.hasPrevious()) {
            String command = commandHistory.commandHistoryIterator.previous();
            commandTextField.replaceText(0, commandTextField.getLength(), command);
            commandTextField.end();
        }

    }

    private void getPreviousCommand() {
        if (commandHistory.commandHistoryIterator.hasNext()) {
            String command = commandHistory.commandHistoryIterator.next();
            commandTextField.replaceText(0, commandTextField.getLength(), command);
            commandTextField.end();
        }
    }
```
