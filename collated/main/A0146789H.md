# A0146789H
###### /reminders-src/reminders.py
``` py

# Provides the Reminders API for Suru

import sendgrid
from sendgrid.helpers.mail import *
from flask import Flask, abort, request
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor
import xml.etree.ElementTree
import dateutil.parser
import datetime
import os
import re

app = Flask(__name__)
sg = sendgrid.SendGridAPIClient(apikey=os.environ.get('SENDGRID_API_KEY'))
executors = {
    'default': ThreadPoolExecutor(20),
    'processpool': ProcessPoolExecutor(5)
}
scheduler = BackgroundScheduler(executors=executors, timezone="Asia/Singapore")
scheduler.start()

email_jobs = {}

FROM_EMAIL = Email("no-reply@suru.com")

def sendmail(email, event, time_delta):
    print "Starting mail to %s for %s before %d" % (email, event, time_delta)
    subject = "[Reminder]: %s" % event
    to_email = Email(email)
    words = "Here's a friendly reminder to attend your '%s'! It's happening in %d minutes!"
    words = words % (event, time_delta)
    content = Content("text/plain", words)
    mail= Mail(FROM_EMAIL, subject, to_email, content)
    response = sg.client.mail.send.post(request_body=mail.get())
    print response.status_code
    print response.body
    print response.headers
    return response

def process(file_data, email, time):
    print file_data
    print email
    print time
    if email in email_jobs:
        for i in email_jobs[email]:
            i.remove()
        del email_jobs[email]

    jobs = []

    try:
        root = xml.etree.ElementTree.fromstring(file_data)
    except:
        return False

    for task in root.findall("task"):
        name = task.find("name")
        start_date = task.find("startDate")
        completion_status = task.find("completionStatus")
        if completion_status is not None and completion_status.text == "true":
            continue
        if start_date is not None:
            scheduled = dateutil.parser.parse(start_date.text)
            actual = scheduled - datetime.timedelta(minutes=time)
            job = scheduler.add_job(sendmail, "date",
                                    [email, name.text, time],
                                    next_run_time=actual)

            print job
            jobs.append(job)

    email_jobs[email] = jobs
    return True

@app.route('/')
def index():
    return 'Suru Reminders API'

@app.route('/register/<email>/<int:time>/<action>', methods=["POST"])
def register(email, time, action):
    # Check if the email matches the right format
    email_regex = re.compile(r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
    if (not email_regex.match(email)):
        # Abort with a 404 if the regex fails
        abort(404)

    if action == 'disable':
        return "disable " + email

    if action == 'enable':
        # Check if the storage parameter is available
        if 'storage' not in request.files:
            abort(404)

        # Read the data from the file object
        file_data = request.files['storage'].read()

        if (process(file_data, email, time)):
            return "success"
        else:
            abort(404)

    abort(404)

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)
```
###### /reminders-src/email-test.py
``` py
import sendgrid
import os
from sendgrid.helpers.mail import *
import sys

if len(sys.argv) != 3:
    print "python email-test.py from-email to-email"
    exit()

sg = sendgrid.SendGridAPIClient(apikey=os.environ.get('SENDGRID_API_KEY'))
from_email = Email(sys.argv[1])
subject = "Testing Sending Using Sendgrid"
to_email = Email(sys.argv[2])
content = Content("text/plain", "Contents of this test email")
mail = Mail(from_email, subject, to_email, content)
response = sg.client.mail.send.post(request_body=mail.get())
print response.status_code
print response.body
print response.headers
```
###### /java/seedu/task/commons/util/HttpUtil.java
``` java

package seedu.task.commons.util;

import java.io.File;

import com.mashape.unirest.http.HttpResponse;
import com.mashape.unirest.http.Unirest;
import com.mashape.unirest.http.exceptions.UnirestException;

/**
 * Provides utility functions to send HTTP requests.
 *
 * @author amon
 *
 */
public class HttpUtil {

    // Declare the constants for the API
    public static final String API_HOSTNAME = "cs2107.spro.ink";
    public static final int API_PORT = 80;
    public static final String API_ENDPOINT = "/register/";

    /**
     * Uploads a file to the URL
     *
     * @param url
     * @param fileName
     * @param filePath
     * @return true if the file upload was successful.
     */
    public static boolean uploadFile(String url, String fileName, String filePath) {
        try {
            HttpResponse<String> request = Unirest.post(url).field(fileName, new File(filePath)).asString();
            int status = request.getStatus();
            if (status != 200) {
                return false;
            }
        } catch (UnirestException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Uploads the specified save file to the API endpoint.
     *
     * @param email
     * @param filePath
     * @return
     */
    public static boolean pushSaveFile(String email, int time, String filePath) {
        String url = String.format("http://%s:%d%s%s/%d/enable", API_HOSTNAME, API_PORT, API_ENDPOINT, email, time);
        return uploadFile(url, "storage", filePath);
    }

    public static boolean pushDisable(String email) {
        String url = String.format("http://%s:%d%s%s/0/disable", API_HOSTNAME, API_PORT, API_ENDPOINT, email);
        try {
            HttpResponse<String> request = Unirest.post(url).asString();
            int status = request.getStatus();
            if (status != 200) {
                return false;
            }
        } catch (UnirestException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

}
```
###### /java/seedu/task/commons/util/NattyDateUtil.java
``` java
package seedu.task.commons.util;

import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import seedu.task.commons.core.LogsCenter;
import seedu.task.logic.parser.AddCommandParser;

/**
 * @author amon
 *
 * This class provides utility functions to flexibly parse Dates from a string.
 */
public class NattyDateUtil {

    private static final String AMERICAN_DATE_FORMAT = "(?:^|\\s)(?<entire>(?<day>\\d{1,2})\\/(?<month>\\d{1,2})).*";
    private static final Pattern AMERICAN_DATE_PATTERN = Pattern.compile(AMERICAN_DATE_FORMAT);

    private static final Logger logger = LogsCenter.getLogger(AddCommandParser.class);
    private static final String logPrefix = "[AddCommandParser]";

    /**
     * Preprocesses a string before it gets passed to the natty parser
     *
     * @param original string to process
     * @return the processed string
     */
    private static String preprocess(String original) {
        String finalString = original;
        logger.info(String.format("%s Pre-processing string '%s'.", logPrefix,  original));

        // Convert Singaporean date formats into American
        Matcher matcher = AMERICAN_DATE_PATTERN.matcher(original);
        if (matcher.matches()) {
            String entire = matcher.group("entire");
            String day = matcher.group("day");
            String month = matcher.group("month");
            String newDateString = String.format("%s/%s", month, day);
            finalString = original.replace(entire, newDateString);
        }

        logger.info(String.format("%s Pre-processing complete '%s'", logPrefix, finalString));

        return finalString;
    }

    /**
     * Parse a string into a single date object using Natty.
     *
     * @param dataString
     * @return a Date object representing the input date
     */
    public static Date parseSingleDate(String dataString) {
        Parser parser = new Parser();
        List<DateGroup> groups;

        // Pre-process data string to provide quality of life localisations
        dataString = preprocess(dataString);

        groups = parser.parse(dataString);

        logger.info(String.format("%s parsing date string '%s'", logPrefix, dataString));

        // Check if there are any results. If not, return null.
        if (groups.isEmpty() || groups.get(0).getDates().isEmpty()) {
            logger.info(String.format("%s failed to parse date string", logPrefix));
            return null;
        }

        DateGroup dg = groups.get(0);
        Date result = dg.getDates().get(0);
        Date finalDate = result;

        // Log information about the date parsed
        logger.info(String.format("%s date: %s, isDateInferred(): %s, isTimeInferred(): %s",
                    logPrefix, result.toString(), dg.isDateInferred(), dg.isTimeInferred()));

        // If the time was inferred, set the time explicitly to (high) noon.
        if (dg.isTimeInferred()) {
            finalDate = setExplicitTime(result, 12, 0, 0, 0);
            logger.info(String.format("%s newResult: %s", logPrefix, finalDate.toString()));
        }

        return finalDate;
    }

    /**
     * Set the time fields explicitly for a Date object
     *
     * @param original date to modify
     * @param hour to set
     * @param minute to set
     * @param second to set
     * @param millisecond to set
     * @return a new Date object with the supplied values
     */
    public static Date setExplicitTime(Date original, int hour, int minute, int second, int millisecond) {
        // We have to use the Calendar object as a wrapper to avoid deprecated methods
        Calendar modified = Calendar.getInstance();
        modified.setTime(original);
        modified.set(Calendar.HOUR_OF_DAY, hour);
        modified.set(Calendar.MINUTE, minute);
        modified.set(Calendar.SECOND, second);
        modified.set(Calendar.MILLISECOND, millisecond);
        Date newResult = modified.getTime();
        return newResult;
    }

}
```
###### /java/seedu/task/logic/LogicManager.java
``` java
    private final Storage storage;

    public LogicManager(Model model, Storage storage) {
        this.model = model;
        this.parser = new Parser();
        this.storage = storage;
    }

    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        ChatList chatList = getChatList();
        chatList.add(new Chat(commandText, Sender.USER));
        Command command = parser.parseCommand(commandText);
        command.setData(model, storage);
        return command.execute();
    }

```
###### /java/seedu/task/logic/commands/SortCommand.java
``` java
// TODO: This class is unused and is not expected to be implemented for v0.5rc

public class SortCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"sort"};

    public SortCommand() {
        super(COMMAND_WORDS);
        throw new UnsupportedOperationException();
    }

    @Override
    public CommandResult execute() throws CommandException {
        // TODO Auto-generated method stub
        return null;
    }

```
###### /java/seedu/task/logic/commands/SortCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert SortCommand.COMMAND_WORDS != null;

        return isCommandWord(SortCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"help"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Shows program usage instructions.\n"
            + "Example: " + DEFACTO_COMMAND;

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    /**
     * Constructs a command with the relevant command words.
     */
    public HelpCommand() {
        super(COMMAND_WORDS);
    }

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ShowHelpRequestEvent());
        return new CommandResult(SHOWING_HELP_MESSAGE);
    }

```
###### /java/seedu/task/logic/commands/HelpCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert HelpCommand.COMMAND_WORDS != null;

        return isCommandWord(HelpCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"find", "search"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Finds all tasks whose names or tags contain "
            + "any of the specified keywords (case-insensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + DEFACTO_COMMAND + " tutorial lab assignment";

    private Set<String> keywords;
    private final Set<Tag> tagKeywords = new HashSet<>();

    /**
     * Constructs a command with the relevant command words.
     */
    private FindCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/FindCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert FindCommand.COMMAND_WORDS != null;

        return isCommandWord(FindCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/Command.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.EventsCenter;
import seedu.task.commons.core.Messages;
import seedu.task.commons.events.BaseEvent;
import seedu.task.commons.events.ui.NewResultAvailableEvent;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.Model;
import seedu.task.storage.Storage;

/**
 * Represents a command with hidden internal logic and the ability to be executed.
 */
public abstract class Command {
    protected Model model;
    protected Storage storage;

    /**
     * Constructs the class with an array of valid command words.
     *
     * @param COMMAND_WORDS
     */
    public Command(String[] commandWords) {
        super();
    }

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of persons.
     *
     * @param displaySize used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForTaskListShownSummary(int displaySize) {
        return String.format(Messages.MESSAGE_TASKS_LISTED_OVERVIEW, displaySize);
    }

    /**
     * Executes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     * @throws CommandException If an error occurs during command execution.
     */
    public abstract CommandResult execute() throws CommandException;


    /**
     * Provides any needed dependencies to the command.
     * Commands making use of any of these should override this method to gain
     * access to the dependencies.
     */
    public void setData(Model model, Storage storage) {
        this.model = model;
        this.storage = storage;
    }

    /**
     * Checks if the provided command word belongs to this command.
     *
     * @param commmand
     * @return true if it is a command word, false if not.
     */
    protected static boolean isCommandWord(String[] commandWords, String command) {
        for (String i : commandWords) {
            if (i.equals(command)) {
                return true;
            }
        }
        return false;
    }

```
###### /java/seedu/task/logic/commands/IncorrectCommand.java
``` java
/**
 * Represents an incorrect command. Upon execution, throws a CommandException with feedback to the user.
 */
public class IncorrectCommand extends Command {

    public String feedbackToUser;

    /**
     * Constructs a command with no command words.
     */
    private IncorrectCommand() {
        super(new String[]{});
    }

    public IncorrectCommand(String feedbackToUser) {
        this();
        this.feedbackToUser = feedbackToUser;
    }

    @Override
    public CommandResult execute() throws CommandException {
        throw new CommandException(feedbackToUser);
    }

```
###### /java/seedu/task/logic/commands/IncorrectCommand.java
``` java
    public static boolean isCommandWord(String command) {
        return false;
    }
}

```
###### /java/seedu/task/logic/commands/ListCheckedCommand.java
``` java
    public static final String[] LIST_COMMAND_WORDS = new String[] {"checked", "completed"};
    public static final String DEFACTO_COMMAND = LIST_COMMAND_WORDS[0];

    public ListCheckedCommand() {
        super(LIST_COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/ListCheckedCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ListCheckedCommand.LIST_COMMAND_WORDS != null;

        return isCommandWord(ListCheckedCommand.LIST_COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"check", "checked", "complete"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Mark task completion status to check/completed.\n"
            + "Example: " + DEFACTO_COMMAND + " 1\n"
            + "Parameters: INDEX (must be a positive integer)";

```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    protected CheckCommand () {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert CheckCommand.COMMAND_WORDS != null;

        return isCommandWord(CheckCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/UncheckCommand.java
``` java
public class UncheckCommand extends TaskCompleted {
    public static final String[] COMMAND_WORDS = new String[] {"uncheck", "unchecked", "incomplete"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Mark task completion status "
            + "to unchecked/incompleted."
            + "\n"
            + "Example: " + DEFACTO_COMMAND + " 1\n"
            + "Parameters: INDEX (must be a positive integer)";

```
###### /java/seedu/task/logic/commands/UncheckCommand.java
``` java
    protected UncheckCommand() {
        super(COMMAND_WORDS);
    }

    //@@uauthor
    public UncheckCommand (int filteredTaskListIndex) {
        this();
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMarkComplete = lastShownList.get(filteredTaskListIndex);

        if (taskToMarkComplete.getCompletionStatus().getCompletion() == false) {
            throw new CommandException(String.format(MESSAGE_TASK_ALREADY_UNCHECKED, taskToMarkComplete.getName()));
        }

        Task completedTask = changeTaskCompletion(taskToMarkComplete);

        try {
            model.updateTask(filteredTaskListIndex, completedTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getTaskID(completedTask)));
        return new CommandResult(String.format(MESSAGE_UNCHECK_SUCCESS, taskToMarkComplete.getName()));
    }

```
###### /java/seedu/task/logic/commands/UncheckCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert UncheckCommand.COMMAND_WORDS != null;

        return isCommandWord(UncheckCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"edit", "change", "-e"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Edits the details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) [NAME] [from STARTDATE] [to ENDDATE] [tags]"
            + " ...\n"
            + "Example: " + DEFACTO_COMMAND + " 1 another task from tomorrow to next wednesday #first";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "I have edited the task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "You have not requested any changes to be made, "
            + "please try again.";
    public static final String MESSAGE_DUPLICATE_TASK =
            "Sorry, this task already exists in the task manager.";

    private int filteredTaskListIndex;
    private EditTaskDescriptor editTaskDescriptor;

    public EditCommand() {
        super(COMMAND_WORDS);
    }

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        this();
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
    }

    /**
     * @return the editTaskDescriptor
     */
    public EditTaskDescriptor getEditTaskDescriptor() {
        return editTaskDescriptor;
    }

```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert EditCommand.COMMAND_WORDS != null;

        return isCommandWord(EditCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ClearCommand.java
``` java
/**
 * Clears the address book.
 */
public class ClearCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"clear"};
    public static final String MESSAGE_SUCCESS = "Your task manager has been cleared!";

    /**
     * Creates and empty command with the relevant command words.
     */
    public ClearCommand() {
        super(COMMAND_WORDS);
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        model.resetData(new TaskManager());
        return new CommandResult(MESSAGE_SUCCESS);
    }

```
###### /java/seedu/task/logic/commands/ClearCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ClearCommand.COMMAND_WORDS != null;

        return isCommandWord(ClearCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/SelectCommand.java
``` java
/**
 * Selects a task identified using it's last displayed index from the task manager.
 */
public class SelectCommand extends Command {

    private int targetIndex;

    public static final String[] COMMAND_WORDS = new String[] {"select"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND
            + ": Selects the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + DEFACTO_COMMAND + " 1";

    public static final String MESSAGE_SELECT_TASK_SUCCESS = "Displaying information for task %1$s";
    public static final String MESSAGE_SELECTED_TASK = "\nTask Name: %1$s";

    protected SelectCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/SelectCommand.java
``` java
    /**
     * @return the targetIndex
     */
    public int getTargetIndex() {
        return targetIndex;
    }

```
###### /java/seedu/task/logic/commands/SelectCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert SelectCommand.COMMAND_WORDS != null;

        return isCommandWord(SelectCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"addtag", "addtags"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
    public AddTagCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert CheckCommand.COMMAND_WORDS != null;

        return isCommandWord(AddTagCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ReminderCommand.java
``` java
package seedu.task.logic.commands;

import java.io.IOException;
import java.util.Optional;

import seedu.task.commons.core.Config;
import seedu.task.commons.exceptions.DataConversionException;
import seedu.task.commons.util.ConfigUtil;
import seedu.task.commons.util.HttpUtil;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.UserPrefs;

public class ReminderCommand extends Command {
    public static final String[] COMMAND_WORDS = new String[] {"reminders"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_ENABLED = "Reminders have been enabled and will be synced to the cloud.";
    public static final String MESSAGE_DISABLED = "Reminders have been disabled.";
    public static final String MESSAGE_INCORRECT_ARGS = "Please specify whether to enable or disable reminders!";
    public static final String MESSAGE_USERPREFS_ERROR = "There was an error retrieving the configuration files!";
    public static final String MESSAGE_EMAILNOTSET_ERROR = "There was no email previously set! Use the 'email' "
            + "command!";
    public static final String MESSAGE_SYNCFAILURE_ERROR = "There was an error syncing with the server!";

    private boolean enabled;

    public ReminderCommand() {
        super(COMMAND_WORDS);
    }
    public ReminderCommand(boolean enabled) {
        this();
        this.enabled = enabled;
    }

    @Override
    public CommandResult execute() throws CommandException {
        Optional<UserPrefs> optPrefs = null;
        Optional<Config> optConfig = null;
        try {
            optPrefs = storage.readUserPrefs();
            optConfig = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE);
            if (!optPrefs.isPresent() || !optConfig.isPresent()) {
                return new CommandResult(MESSAGE_USERPREFS_ERROR);
            }
        } catch (DataConversionException e) {
            return new CommandResult(MESSAGE_USERPREFS_ERROR);
        } catch (IOException e) {
            return new CommandResult(MESSAGE_USERPREFS_ERROR);
        }

        UserPrefs prefs = optPrefs.get();
        Config config = optConfig.get();

        if (prefs == null) {
            return new CommandResult(MESSAGE_USERPREFS_ERROR);
        }

        if (prefs.reminderEmail.equals("")) {
            return new CommandResult(MESSAGE_EMAILNOTSET_ERROR);
        }

        // Try to push the file to the server. If it works, then return an affirmative result
        if (enabled && HttpUtil.pushSaveFile(prefs.reminderEmail, prefs.reminderTime,
                config.getTaskManagerFilePath())) {
            return new CommandResult(MESSAGE_ENABLED);
        } else if (!enabled && HttpUtil.pushDisable(prefs.reminderEmail)) {
            return new CommandResult(MESSAGE_DISABLED);
        }

        return new CommandResult(MESSAGE_SYNCFAILURE_ERROR);
    }

    public static boolean isCommandWord(String command) {
        return isCommandWord(ReminderCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"undo"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
    public UndoCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert UndoCommand.COMMAND_WORDS != null;

        return isCommandWord(UndoCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/TaskCompleted.java
``` java
    /**
     * Constructor to pass the valid command words back up to the base class.
     *
     * Protected access modifier is used to restrict access to the subclass.
     * @param COMMAND_WORDS
     */
    protected TaskCompleted(String[] commandWords) {
        super(commandWords);
    }

```
###### /java/seedu/task/logic/commands/SaveToCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"saveto", "save", "export"};

    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/SaveToCommand.java
``` java
    protected SaveToCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/SaveToCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert SaveToCommand.COMMAND_WORDS != null;

        return isCommandWord(SaveToCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the task manager.
 */
public class DeleteCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"delete", "del", "remove", "-d", "rm"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + DEFACTO_COMMAND + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "The Task: %1$s has been deleted!";

    public int targetIndex;

    /**
     *  Creates an empty delete command with the relevant commands words.
     *
     */
    protected DeleteCommand() {
        super(COMMAND_WORDS);
    }

    public DeleteCommand(int targetIndex) {
        this();
        this.targetIndex = targetIndex;
    }

```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert DeleteCommand.COMMAND_WORDS != null;

        return isCommandWord(DeleteCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/LoadFromCommand.java
``` java

    public static final String[] COMMAND_WORDS = new String[] {"loadfrom", "load", "import"};

    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Defines a new load location for your tasks "
            + "Parameters: FILE_PATH"
            + "Example: " + DEFACTO_COMMAND
            + " ./taskmanager.xml";


    private LoadFromCommand() {
        super(COMMAND_WORDS);
    }

    public LoadFromCommand(String filepath) {
        this();
        this.setFilepath(filepath);
        registerAsAnEventHandler(this);
    }

```
###### /java/seedu/task/logic/commands/LoadFromCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert LoadFromCommand.COMMAND_WORDS != null;

        return isCommandWord(LoadFromCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ListCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"list", "ls"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_SUCCESS = "All tasks has been listed!";

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Lists all tasks with index numbers, "
            + "use checked/unchecked/deadline/event/someday/upcoming/overdue as a keyword to only "
            + "show tasks of that type. Only one keyword is allowed. \n"
            + "Parameters: [" + ListUncheckedCommand.DEFACTO_COMMAND + "]["
            + ListCheckedCommand.DEFACTO_COMMAND + "][" + ListDeadlineCommand.DEFACTO_COMMAND
            + "][" + ListEventCommand.DEFACTO_COMMAND + "][" + ListFloatingCommand.DEFACTO_COMMAND
            + "][" + ListUpcomingCommand.DEFACTO_COMMAND + "][" + ListOverdueCommand.DEFACTO_COMMAND + "]\n"
            + "Example: " + DEFACTO_COMMAND + " " + ListUncheckedCommand.DEFACTO_COMMAND;

    public ListCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/ListCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ListCommand.COMMAND_WORDS != null;

        return isCommandWord(ListCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ReminderTimeCommand.java
``` java
package seedu.task.logic.commands;

import java.io.IOException;
import java.util.Optional;

import seedu.task.commons.exceptions.DataConversionException;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.UserPrefs;

/**
 * @author amon
 *
 */
public class ReminderTimeCommand extends Command {
    public static final String[] COMMAND_WORDS = new String[] {"remindme", "remindtime"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_SUCCESS = "New reminder time set successfully! Will remind %d minutes"
            + " before the event!";
    public static final String MESSAGE_INCORRECT = "Please specify a valid integer!";
    public static final String MESSAGE_USERPREFS_ERROR = "There was an error retrieving/saving the preferences file!";

    private int time;

    public ReminderTimeCommand() {
        super(COMMAND_WORDS);
    }

    public ReminderTimeCommand(int time) {
        this();
        this.time = time;
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.commands.Command#execute()
     */
    @Override
    public CommandResult execute() throws CommandException {
        try {
            Optional<UserPrefs> optPrefs = storage.readUserPrefs();
            if (!optPrefs.isPresent()) {
                return new CommandResult(MESSAGE_USERPREFS_ERROR);
            }
            UserPrefs prefs = optPrefs.get();
            prefs.setReminderTime(time);
            storage.saveUserPrefs(prefs);
        } catch (DataConversionException e) {
            return new CommandResult(MESSAGE_USERPREFS_ERROR);
        } catch (IOException e) {
            return new CommandResult(MESSAGE_USERPREFS_ERROR);
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, time));
    }

    public static boolean isCommandWord(String command) {
        return isCommandWord(ReminderTimeCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ListUncheckedCommand.java
``` java
    public static final String[] LIST_COMMAND_WORDS = new String[] {"unchecked"};
    public static final String DEFACTO_COMMAND = LIST_COMMAND_WORDS[0];

    public ListUncheckedCommand() {
        super(LIST_COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/ListUncheckedCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ListUncheckedCommand.LIST_COMMAND_WORDS != null;

        return isCommandWord(ListUncheckedCommand.LIST_COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"add", "-a"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Adds a task to the task manager. "
            + "Parameters: DESCRIPTION [from START_DATE to END_DATE][by END_DATE] #TAGS\n"
            + "Example: " + DEFACTO_COMMAND
            + " Do CS2103 tutorial from saturday noon to saturday night #CS2103 #uni";

    public static final String MESSAGE_SUCCESS = "Your new task has been added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK =
            "Sorry, this task already exists in the task manager";

    private Task toAdd;

    /**
     * Creates an empty command with the relevant command words.
     *
     */
    public AddCommand() {
        super(COMMAND_WORDS);
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name)
            throws IllegalValueException {
        this();
        final Set<Tag> tagSet = new HashSet<>();
        this.toAdd = new Task(
                new Name(name),
                new StartTime(null),
                new EndTime(null),
                new CompletionStatus(false),
                new UniqueTagList(tagSet)
        );
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, Date startDate, Date endDate, boolean completionStatus, Set<String> tags)
            throws IllegalValueException {
        this();
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new StartTime(startDate),
                new EndTime(endDate),
                new CompletionStatus(completionStatus),
                new UniqueTagList(tagSet)
                );
    }

    /**
     * @return the task to be added
     */
    public Task getToAdd() {
        return toAdd;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getTaskID(toAdd)));
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

    }
```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert AddCommand.COMMAND_WORDS != null;

        return isCommandWord(AddCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/EmailCommand.java
``` java
package seedu.task.logic.commands;

import java.io.IOException;
import java.util.Optional;

import seedu.task.commons.exceptions.DataConversionException;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.UserPrefs;

/**
 * @author amon
 *
 */
public class EmailCommand extends Command {
    public static final String[] COMMAND_WORDS = new String[] {"email", "setemail", "mailto"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_SUCCESS = "The new email has been set successfully!";
    public static final String MESSAGE_INCORRECT = "Please specify a valid email!";
    public static final String MESSAGE_USERPREFS_ERROR = "There was an error retrieving/saving the preferences file!";

    private String email;

    public EmailCommand() {
        super(COMMAND_WORDS);
    }

    public EmailCommand(String email) {
        this();
        this.email = email;
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.commands.Command#execute()
     */
    @Override
    public CommandResult execute() throws CommandException {
        try {
            Optional<UserPrefs> optPrefs = storage.readUserPrefs();
            if (!optPrefs.isPresent()) {
                return new CommandResult(MESSAGE_USERPREFS_ERROR);
            }
            UserPrefs prefs = optPrefs.get();
            prefs.setReminderEmail(email);
            storage.saveUserPrefs(prefs);
        } catch (DataConversionException e) {
            return new CommandResult(MESSAGE_USERPREFS_ERROR);
        } catch (IOException e) {
            return new CommandResult(MESSAGE_USERPREFS_ERROR);
        }
        return new CommandResult(MESSAGE_SUCCESS);
    }

    public static boolean isCommandWord(String command) {
        return isCommandWord(EmailCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"deltag", "deltags"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
    public DeleteTagCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert CheckCommand.COMMAND_WORDS != null;

        return isCommandWord(DeleteTagCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ExitCommand.java
``` java
/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"exit", "quit"};

    public static final String MESSAGE_EXIT_ACKNOWLEDGEMENT = "Exiting suru, see you next time!";

    /**
     * Constructs a command with the relevant command words.
     */
    public ExitCommand() {
        super(COMMAND_WORDS);
    }

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
        return new CommandResult(MESSAGE_EXIT_ACKNOWLEDGEMENT);
    }

```
###### /java/seedu/task/logic/commands/ExitCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ExitCommand.COMMAND_WORDS != null;

        return isCommandWord(ExitCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"redo"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
    public RedoCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert RedoCommand.COMMAND_WORDS != null;

        return isCommandWord(RedoCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/parser/LoadFromCommandParser.java
``` java

public class LoadFromCommandParser extends AbstractParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        return new LoadFromCommand(args);
    }

    @Override
    public boolean isAcceptedCommand(String command) {
        return LoadFromCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/ParserUtil.java
``` java
/**
 * Contains utility methods used for parsing strings in the various *Parser classes
 */
public class ParserUtil {

    private static final Pattern INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    /**
     * Returns the specified index in the {@code command} if it is a positive unsigned integer
     * Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<Integer> parseIndex(String command) {
        final Matcher matcher = INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty,
     * or if the list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

    /**
     * Splits a preamble string into ordered fields.
     * @return A list of size {@code numFields} where the ith element is the ith field value if specified in
     *         the input, {@code Optional.empty()} otherwise.
     */
    public static List<Optional<String>> splitPreamble(String preamble, int numFields) {
        return Arrays.stream(Arrays.copyOf(preamble.split("\\s+", numFields), numFields))
                .map(Optional::ofNullable)
                .collect(Collectors.toList());
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code String name} into a {@code Optional<Name>} if {@code name} is present.
     *
     * @param name
     * @return
     * @throws IllegalValueException
     */
    public static Optional<Name> parseName(String name) throws IllegalValueException {
        assert name != null;
        String tempName = name.equals("") ? null : name;
        return parseName(Optional.ofNullable(tempName));
    }

    /**
     * Parses a {@code Optional<String> completionStatus} into an
     * {@code Optional<CompletionStatus>} if {@code completionStatus} is present.
     */
    public static Optional<CompletionStatus> parseCompletionStatus(Optional<String> completionStatus)
            throws IllegalValueException {
        assert completionStatus != null;
        return completionStatus.isPresent() ?
                Optional.of(new CompletionStatus(Boolean.valueOf(completionStatus.get()))) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> startDate} into an {@code Optional<StartTime>} if {@code startDate} is present.
     */
    public static Optional<StartTime> parseStartTime(Optional<Date> startDate) throws IllegalValueException {
        assert startDate != null;
        return startDate.isPresent() ? Optional.of(new StartTime(startDate.get())) : Optional.empty();
    }

    /**
     * Parses a {@code String startDate} into an {@code Optional<StartTime>} if {@code startDate} is present.
     */
    public static Optional<StartTime> parseStartTime(String startDate) throws IllegalValueException {
        String processedDate = Optional.ofNullable(startDate).orElse("");
        Date parsedDate = NattyDateUtil.parseSingleDate(processedDate);
        return parseStartTime(Optional.ofNullable(parsedDate));
    }

    /**
     * Parses a {@code Optional<String> endDate} into an {@code Optional<EndTime>} if {@code endDate} is present.
     */
    public static Optional<EndTime> parseEndTime(Optional<Date> endDate) throws IllegalValueException {
        assert endDate != null;
        return endDate.isPresent() ? Optional.of(new EndTime(endDate.get())) : Optional.empty();
    }

    /**
     * Parses a {@code String endDate} into an {@code Optional<EndTime>} if {@code endDate} is present.
     */
    public static Optional<EndTime> parseEndTime(String endDate) throws IllegalValueException {
        String processedDate = Optional.ofNullable(endDate).orElse("");
        Date parsedDate = NattyDateUtil.parseSingleDate(processedDate);
        return parseEndTime(Optional.ofNullable(parsedDate));
    }

    /**
     * Parses {@code Collection<String> tags} into an {@code UniqueTagList}.
     */
    public static UniqueTagList parseTags(Collection<String> tags) throws IllegalValueException {
        assert tags != null;
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        return new UniqueTagList(tagSet);
    }

     /**
     * Parses {@code Collection<String> tags} into an {@code Optional<UniqueTagList>} if {@code tags} is non-empty.
     * If {@code tags} contain only one element which is an empty string, it will be parsed into a
     * {@code Optional<UniqueTagList>} containing zero tags.
     */
    public static Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

    /**
     * Split the tags string into a set.
     * Example: "#one #two" into ["one", "two"]
     *
     * @param tagsString
     * @return
     */
    public static Set<String> parseTagStringToSet(String tagsString) {
        Set<String> tagSet = new HashSet<String>();
        for (String i : tagsString.split("\\s+")) {
            if (i.length() > 1) {
                tagSet.add(i.substring(1));
            }
        }
        return tagSet;
    }
}
```
###### /java/seedu/task/logic/parser/ListFloatingCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListFloatingCommand;

/**
 * @author amon
 *
 */
public class ListFloatingCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListFloatingCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListFloatingCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/Parser.java
``` java
/**
 * Parses user input.
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     * Allows for case insensitive matching.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)",
            Pattern.CASE_INSENSITIVE);

    private static final Logger logger = LogsCenter.getLogger(Parser.class);
    private static final String logPrefix = "[PARSER]";

    // Parsers are registered here as an AbstractParser ArrayList.
    private static final ArrayList<AbstractParser> registeredParsers = new ArrayList<AbstractParser>();

    public Parser() {
        /*
         *  Register the parsers individually on setup.
         *  The order of the parsers registered is important.
         */

        registeredParsers.add(new AddCommandParser());
        registeredParsers.add(new EditCommandParser());
        registeredParsers.add(new SelectCommandParser());
        registeredParsers.add(new DeleteCommandParser());
        registeredParsers.add(new ClearCommandParser());
        registeredParsers.add(new FindCommandParser());
        registeredParsers.add(new ListCommandParser());
        registeredParsers.add(new ExitCommandParser());
        registeredParsers.add(new HelpCommandParser());
        registeredParsers.add(new CheckCommandParser());
        registeredParsers.add(new UncheckCommandParser());
        registeredParsers.add(new UndoCommandParser());
        registeredParsers.add(new RedoCommandParser());
        registeredParsers.add(new SaveToCommandParser());
        registeredParsers.add(new LoadFromCommandParser());
        registeredParsers.add(new SortCommandParser());
        registeredParsers.add(new AddTagsParser());
        registeredParsers.add(new DeleteTagsParser());
        registeredParsers.add(new ReminderCommandParser());
        registeredParsers.add(new EmailCommandParser());
        registeredParsers.add(new ReminderTimeCommandParser());
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        logger.info(logPrefix + " Raw User Input: '" + userInput + "'");

        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord").toLowerCase();
        final String arguments = matcher.group("arguments").trim();

        logger.info(logPrefix + " Command Word: '" + commandWord + "'");
        logger.info(logPrefix + " Arguments: '" + arguments + "'");

        // Run through the registered parsers and return the command if valid
        for (AbstractParser parser : registeredParsers) {
            if (parser.isAcceptedCommand(commandWord)) {
                return parser.parse(arguments);
            }
        }

        // Handle the default case.
        return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
    }
}
```
###### /java/seedu/task/logic/parser/UncheckCommandParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return UncheckCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/SortCommandParser.java
``` java

public class SortCommandParser  extends AbstractParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        return new SortCommand();
    }

    @Override
    public boolean isAcceptedCommand(String command) {
        return SortCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/SelectCommandParser.java
``` java
/**
 * Parses input arguments and creates a new SelectCommand object
 */
public class SelectCommandParser extends AbstractParser {

    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return SelectCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/SaveToCommandParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return SaveToCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/HelpCommandParser.java
``` java
/**
 * @author amon
 *
 */
public class HelpCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new HelpCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return HelpCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/CheckCommandParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return CheckCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/EditCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser extends AbstractParser {

    private static final String PATTERN_MANDATORY_INDEX = "(?<index>[1-9]\\d*)";
    private static final String PATTERN_OPTIONAL_DESCRIPTION = "(?:\\s+(?<description>[^#]+?))?";
    private static final String PATTERN_OPTIONAL_STARTDATE = "(?:\\s+(?:from|after|on)\\s+(?<startdate>.+?))?";
    private static final String PATTERN_OPTIONAL_ENDDATE = "(?:\\s+(?:to|by)\\s+(?<enddate>.+?))?";
    private static final String PATTERN_OPTIONAL_TAGS = "(?<tags>(?:\\s+#\\w+)+)?";
    private static final String ARGUMENTS_PATTERN = "^" + PATTERN_MANDATORY_INDEX + PATTERN_OPTIONAL_DESCRIPTION
            + PATTERN_OPTIONAL_STARTDATE + PATTERN_OPTIONAL_ENDDATE + PATTERN_OPTIONAL_TAGS + "$";
    private static final String ARGUMENTS_PATTERN_QUOTED = "^" + PATTERN_MANDATORY_INDEX
            + PATTERN_OPTIONAL_STARTDATE + PATTERN_OPTIONAL_ENDDATE + PATTERN_OPTIONAL_TAGS + "$";

    private static final Pattern ARGUMENTS_FORMAT = Pattern.compile(ARGUMENTS_PATTERN, Pattern.CASE_INSENSITIVE);
    private static final Pattern ARGUMENTS_FORMAT_QUOTED = Pattern.compile(
            ARGUMENTS_PATTERN_QUOTED, Pattern.CASE_INSENSITIVE);

    private static final Logger logger = LogsCenter.getLogger(AddCommandParser.class);
    private static final String logPrefix = "[EditCommandParser]";

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        assert args != null;

        int index;
        String taskName = null;
        String startDateString;
        String endDateString;
        String tagsString;
        String argsToCheck = args;

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();


        try {
            // Check for quoted task names
            if (args.matches(".*'.*'")) {
                int firstIndex = args.indexOf('\'');
                int nextIndex = args.lastIndexOf('\'');
                taskName = args.substring(firstIndex + 1, nextIndex);

                // Remove the task name from the command
                argsToCheck = args.replace("'" + taskName + "'", "").trim();
            }

            logger.info(String.format("%s argsToCheck: '%s'", logPrefix, argsToCheck));

            // Extract the tokens from the argument string.
            Matcher matcher;
            if (taskName == null) {
                matcher = ARGUMENTS_FORMAT.matcher(argsToCheck);
            } else {
                matcher = ARGUMENTS_FORMAT_QUOTED.matcher(argsToCheck);
            }
            if (!matcher.matches()) {
                throw new NoSuchElementException();
            }

            // Extract the matcher groups
            if (taskName == null) {
                taskName = Optional.ofNullable(matcher.group("description")).orElse("").trim();
            }
            index = ParserUtil.parseIndex(matcher.group("index")).get();
            startDateString = Optional.ofNullable(matcher.group("startdate")).orElse("");
            endDateString = Optional.ofNullable(matcher.group("enddate")).orElse("");
            tagsString = Optional.ofNullable(matcher.group("tags")).orElse("").trim();

            // Remove the quotes if available
            if (!taskName.isEmpty()) {
                taskName = taskName.charAt(0) == '\'' ? taskName.substring(1) : taskName;
                int lastIndex = taskName.length() - 1;
                taskName = taskName.charAt(lastIndex) == '\'' ? taskName.substring(0, lastIndex) : taskName;
            }

            // Log tokens for debugging.
            logger.info(String.format("%s taskName: '%s', startDateString: '%s', endDateString: '%s', tags: '%s'",
                    logPrefix, taskName, startDateString, endDateString, tagsString));

            // Set the EditTaskDescriptor change values.
            if (!taskName.isEmpty()) {
                editTaskDescriptor.setName(ParserUtil.parseName(taskName));
            }
            editTaskDescriptor.setStartTime(ParserUtil.parseStartTime(startDateString));
            editTaskDescriptor.setEndTime(ParserUtil.parseEndTime(endDateString));
            editTaskDescriptor.setTags(ParserUtil.parseTagsForEdit(ParserUtil.parseTagStringToSet(tagsString)));

        } catch (NoSuchElementException nsee) {
            // TODO: This needs to be changed to the default case of search.
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }

        // Add the undo entry after successfully parsing an EditCommand.
        UndoManager.pushUndoCommand(EditCommand.DEFACTO_COMMAND);

        return new EditCommand(index, editTaskDescriptor);
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return EditCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListUpcomingCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListUpcomingCommand;

public class ListUpcomingCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListUpcomingCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListUpcomingCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListCommandParser.java
``` java
    public ListCommandParser() {
        registeredParsers.add(new ListUncheckedCommandParser());
        registeredParsers.add(new ListCheckedCommandParser());
        registeredParsers.add(new ListFloatingCommandParser());
        registeredParsers.add(new ListDeadlineCommandParser());
        registeredParsers.add(new ListEventCommandParser());
        registeredParsers.add(new ListUpcomingCommandParser());
        registeredParsers.add(new ListOverdueCommandParser());
    }

    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns an istCommand/ListUncheckedCommand/ListCheckedCommand object for execution.
     */
    @Override
    public Command parse(String args) {

        // keywords delimited by whitespace
        final String keywords = args.trim();

        // if list is used without any keywords, return entire task list
        if (keywords.isEmpty()) {
            return new ListCommand();
        }

        // Run through the registered parsers and return the command if valid
        for (AbstractParser parser : registeredParsers) {
            if (parser.isAcceptedCommand(keywords)) {
                return parser.parse(keywords);
            }
        }

        // Return the incorrect command message if none matches.
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                ListCommand.MESSAGE_USAGE));
    }

```
###### /java/seedu/task/logic/parser/ListCommandParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
/**
 * @author amon
 *
 */
public class AddCommandParser extends AbstractParser {

    private static final String PATTERN_MANDATORY_DESCRIPTION = "(?<description>.+?)";
    private static final String PATTERN_OPTIONAL_STARTDATE = "(?:\\s+(?:from|after|on)\\s+(?<startdate>.+?))?";
    private static final String PATTERN_OPTIONAL_ENDDATE = "(?:\\s+(?:to|by)\\s+(?<enddate>.+?))?";
    private static final String PATTERN_OPTIONAL_TAGS = "(?<tags>(?:\\s+#\\w+)+)?";
    private static final String ARGUMENTS_PATTERN = "^" + PATTERN_MANDATORY_DESCRIPTION + PATTERN_OPTIONAL_STARTDATE
            + PATTERN_OPTIONAL_ENDDATE + PATTERN_OPTIONAL_TAGS + "$";
    private static final String ARGUMENTS_PATTERN_QUOTED = "^" + PATTERN_MANDATORY_DESCRIPTION
            + PATTERN_OPTIONAL_STARTDATE + PATTERN_OPTIONAL_ENDDATE + PATTERN_OPTIONAL_TAGS + "$";
    private static final Pattern ARGUMENTS_FORMAT = Pattern.compile(ARGUMENTS_PATTERN, Pattern.CASE_INSENSITIVE);
    private static final Pattern ARGUMENTS_FORMAT_QUOTED = Pattern.compile(
            ARGUMENTS_PATTERN_QUOTED, Pattern.CASE_INSENSITIVE);

    private static final Logger logger = LogsCenter.getLogger(AddCommandParser.class);
    private static final String logPrefix = "[AddCommandParser]";

    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    @Override
    public Command parse(String args) {

        assert args != null;

        String taskName = null;
        String startDateString;
        String endDateString;
        String tagsString;
        Date startDate = null;
        Date endDate = null;

        Set<String> tagSet = new HashSet<String>();

        try {
            // Check for quoted task names
            if (args.length() > 0 && args.charAt(0) == '\'') {
                int nextIndex = args.indexOf('\'', 1);
                if (nextIndex > 0) {
                    taskName = args.substring(1, nextIndex);
                    args = args.substring(nextIndex);
                }
            }

            // Extract the tokens from the argument string using the appropriate pattern.
            Matcher matcher;
            if (taskName == null) {
                matcher = ARGUMENTS_FORMAT.matcher(args);
            } else {
                matcher = ARGUMENTS_FORMAT_QUOTED.matcher(args);
            }

            // Match on the processed arguments.
            if (!matcher.matches()) {
                throw new NoSuchElementException();
            }

            assert !args.isEmpty();

            // Extract the matcher groups
            if (taskName == null) {
                taskName = matcher.group("description");
            }

            startDateString = Optional.ofNullable(matcher.group("startdate")).orElse("");
            endDateString = Optional.ofNullable(matcher.group("enddate")).orElse("");
            tagsString = Optional.ofNullable(matcher.group("tags")).orElse("").trim();

            // Log tokens for debugging.
            logger.info(String.format("%s taskName: '%s', startDateString: '%s', endDateString: '%s', tags: '%s'",
                    logPrefix, taskName, startDateString, endDateString, tagsString));

            // Convert the String to Date objects
            startDate = NattyDateUtil.parseSingleDate(startDateString);
            endDate = NattyDateUtil.parseSingleDate(endDateString);

            // Remove the quotes if available
            taskName = taskName.charAt(0) == '\'' ? taskName.substring(1) : taskName;
            int lastIndex = taskName.length() - 1;
            taskName = taskName.charAt(lastIndex) == '\'' ? taskName.substring(0, lastIndex) : taskName;

            // Log the dates for debugging.
            if (startDate != null) {
                logger.info(String.format("%s startDate: %s", logPrefix, startDate.toString()));
            }
            if (endDate != null) {
                logger.info(String.format("%s endDate: %s", logPrefix, endDate.toString()));
            }

            // Add each tag to the tag set.
            tagSet = ParserUtil.parseTagStringToSet(tagsString);

            // Log the tags
            logger.info(String.format("%s tagSet: %s", logPrefix, tagSet.toString()));

            // Add the undo entry after successfully parsing an AddCommand
            UndoManager.pushUndoCommand(AddCommand.DEFACTO_COMMAND);

            return new AddCommand(
                    taskName,
                    startDate,
                    endDate,
                    false,
                    tagSet);
        } catch (NoSuchElementException nsee) {
            // TODO: This needs to be changed to the default case of search.
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return AddCommand.isCommandWord(command);
    }
}

```
###### /java/seedu/task/logic/parser/ListOverdueCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListOverdueCommand;

/**
 * @author amon
 *
 */
public class ListOverdueCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListOverdueCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListOverdueCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ReminderTimeCommandParser.java
``` java
package seedu.task.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.ReminderTimeCommand;

/**
 * @author amon
 *
 */
public class ReminderTimeCommandParser extends AbstractParser {
    public static final String PATTERN_POSITIVE_INT = "(^[1-9]\\d*$)";
    public static final Pattern ARGUMENTS_POSINT = java.util.regex.Pattern.compile(PATTERN_POSITIVE_INT);

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        String toMatch = args.trim();
        Matcher matcher = ARGUMENTS_POSINT.matcher(toMatch);
        if (matcher.matches()) {
            return new ReminderTimeCommand(Integer.parseInt(matcher.group(1)));
        }
        return new IncorrectCommand(ReminderTimeCommand.MESSAGE_INCORRECT);
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ReminderTimeCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/ClearCommandParser.java
``` java
public class ClearCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ClearCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ClearCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/FindCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser extends AbstractParser {

    /**
     * Parses the given {@code String} of arguments in the context of the FindCommand
     * and returns an FindCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        // converts keywords to lower case to allow case-insensitive search
        for (String s: keywords) {
            s.toLowerCase();
        }
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    @Override
    public boolean isAcceptedCommand(String command) {
        return FindCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/RedoCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.RedoCommand;

/**
 * @author amon
 *
 */
public class RedoCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new RedoCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return RedoCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/AbstractParser.java
``` java
/**
 * @author amon
 *
 * Abstract class for all parsers to allow for easier registration of parsers.
 */
public abstract class AbstractParser {
    /** Parses the given string arguments into a command if valid.
     *
     * @param args
     * @return
     */
    public abstract Command parse(String args);

    /** Checks if the provided command word is a valid alias of the command.
     *
     * @param command
     * @return true if the word is a valid alias, false otherwise.
     */
    public abstract boolean isAcceptedCommand(String command);
}
```
###### /java/seedu/task/logic/parser/ListUncheckedCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListUncheckedCommand;

/**
 * @author amon
 *
 */
public class ListUncheckedCommandParser extends AbstractParser {

    @Override
    public Command parse(String args) {
        return new ListUncheckedCommand();
    }

    @Override
    public boolean isAcceptedCommand(String command) {
        return ListUncheckedCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ReminderCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.ReminderCommand;

/**
 * @author amon
 *
 */
public class ReminderCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        String option = args.trim().toLowerCase();
        if (option.equals("enable") || option.equals("sync")) {
            return new ReminderCommand(true);
        } else if (args.equals("disable")) {
            return new ReminderCommand(false);
        }
        return new IncorrectCommand(ReminderCommand.MESSAGE_INCORRECT_ARGS);
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ReminderCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser extends AbstractParser {

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    @Override
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent() || index.get() <= 0) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        // Add the undo entry after the DeleteCommand is successfully parsed.
        UndoManager.pushUndoCommand(DeleteCommand.DEFACTO_COMMAND);

        return new DeleteCommand(index.get());
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return DeleteCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/ListEventCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListEventCommand;

public class ListEventCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListEventCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListEventCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/UndoCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.UndoCommand;

/**
 * @author amon
 *
 */
public class UndoCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new UndoCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return UndoCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/EmailCommandParser.java
``` java
package seedu.task.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.EmailCommand;
import seedu.task.logic.commands.IncorrectCommand;

/**
 * @author amon
 *
 */
public class EmailCommandParser extends AbstractParser {
    public static final String PATTERN_EMAIL_ADDRESS = "(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)";
    public static final Pattern ARGUMENTS_EMAIL = java.util.regex.Pattern.compile(PATTERN_EMAIL_ADDRESS);

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        String toMatch = args.trim();
        Matcher matcher = ARGUMENTS_EMAIL.matcher(toMatch);
        if (matcher.matches()) {
            return new EmailCommand(matcher.group(1));
        }
        return new IncorrectCommand(EmailCommand.MESSAGE_INCORRECT);
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return EmailCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/ExitCommandParser.java
``` java
/**
 * @author amon
 *
 */
public class ExitCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ExitCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ExitCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListCheckedCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListCheckedCommand;

/**
 * @author amon
 *
 */
public class ListCheckedCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListCheckedCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListCheckedCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/AddTagsParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return AddTagCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/DeleteTagsParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return DeleteTagCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/model/task/StartTime.java
``` java
/**
 * Represents a task's start time in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidTime(String)}
 */
public class StartTime {

    public static final String MESSAGE_TIME_CONSTRAINTS = ""; // Validation on string no longer necessary in model.

    public final Date value;

    /**
     * @return the value
     */
    public Date getValue() {
        return value;
    }

    /**
     * Validates given start time.
     *
     * @throws IllegalValueException if given time string is invalid.
     */
    public StartTime(Date startTime) throws IllegalValueException {
        if (!isValidTime(startTime)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        this.value = startTime;
    }

    /**
     * Returns true if a given string is a valid task start time.
     */
    public static boolean isValidTime(Date test) {
        //return (test.matches(TIME_VALIDATION_REGEX) || test.matches(EMPTY_TIME_VALIDATION_REGEX));
        return true;
    }

```
###### /java/seedu/task/model/UserPrefs.java
``` java

package seedu.task.model;

import java.util.Objects;

import seedu.task.commons.core.GuiSettings;

/**
 * Represents User's preferences.
 */
public class UserPrefs {

    public GuiSettings guiSettings;
    public String reminderEmail;
    public int reminderTime;

    public GuiSettings getGuiSettings() {
        return guiSettings == null ? new GuiSettings() : guiSettings;
    }

    public void updateLastUsedGuiSetting(GuiSettings guiSettings) {
        this.guiSettings = guiSettings;
    }

    public UserPrefs() {
        this.setGuiSettings(500, 500, 0, 0);
        this.reminderEmail = ""; // Empty email signifies no reminders
        this.reminderTime = 5; // Number of minutes before to remind
    }

    public void setGuiSettings(double width, double height, int x, int y) {
        guiSettings = new GuiSettings(width, height, x, y);
    }

    public void setReminderEmail(String email) {
        this.reminderEmail = email;
    }

    public void setReminderTime(int time) {
        this.reminderTime = time;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }
        if (!(other instanceof UserPrefs)) { //this handles null as well.
            return false;
        }

        UserPrefs o = (UserPrefs) other;

        if (!reminderEmail.equals(o.reminderEmail)) {
            return false;
        }

        if (reminderTime != o.reminderTime) {
            return false;
        }

        return Objects.equals(guiSettings, o.guiSettings);
    }

    @Override
    public int hashCode() {
        return Objects.hash(guiSettings);
    }

    @Override
    public String toString() {
        String result = String.format("reminderEmail: %s\nreminderTime: %d\n%s", reminderEmail,
                reminderTime, guiSettings.toString());
        return result;
    }

}
```
###### /java/seedu/task/MainApp.java
``` java
    @Subscribe
    public void handleExitAppRequestEvent(ExitAppRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));

        // Sync the save file to the cloud if the email is set on the exit event.
        Optional<UserPrefs> optPrefs = null;
        Optional<Config> optConfig = null;
        try {
            optPrefs = storage.readUserPrefs();
            optConfig = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE);
        } catch (DataConversionException | IOException e1) {
            e1.printStackTrace();
        }

        if (optPrefs != null && optConfig != null &&  optPrefs.isPresent() && optConfig.isPresent()) {
            UserPrefs prefs = optPrefs.get();
            Config config = optConfig.get();
            if (!prefs.reminderEmail.equals("")) {
                HttpUtil.pushSaveFile(prefs.reminderEmail, prefs.reminderTime, config.getTaskManagerFilePath());
            }
        }

        this.stop();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
