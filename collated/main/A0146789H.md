# A0146789H
###### /java/seedu/task/commons/util/NattyDateUtil.java
``` java
/**
 * @author amon
 *
 * This class provides utility functions to flexibly parse Dates from a string.
 */
public class NattyDateUtil {

    /**
     * Parse a string into a single date object using Natty.
     *
     * @param dataString
     * @return a Date object representing the input date
     */
    public static Date parseSingleDate(String dataString) {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(dataString);

        // Check if there are any results. If not, return null.
        if (groups.isEmpty() || groups.get(0).getDates().isEmpty()) {
            return null;
        }

        return groups.get(0).getDates().get(0);
    }

}
```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"add", "-a"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Adds a task to the task manager. "
            + "Parameters: DESCRIPTION from START_DATE to END_DATE #TAGS\n"
            + "Example: " + DEFACTO_COMMAND
            + " Do CS2103 tutorial from 03/06/17 to 03/08/17 #CS2103 #uni";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";

    private Task toAdd;

    /**
     * Creates an empty command with the relevant command words.
     *
     */
    public AddCommand() {
        super(COMMAND_WORDS);
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name)
            throws IllegalValueException {
        this();
        final Set<Tag> tagSet = new HashSet<>();
        this.toAdd = new Task(
                new Name(name),
                new StartTime(null),
                new EndTime(null),
                new CompletionStatus(false),
                new UniqueTagList(tagSet)
        );
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, Date startDate, Date endDate, boolean completionStatus, Set<String> tags)
            throws IllegalValueException {
        this();
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new StartTime(startDate),
                new EndTime(endDate),
                new CompletionStatus(completionStatus),
                new UniqueTagList(tagSet)
                );
    }

    /**
     * @return the task to be added
     */
    public Task getToAdd() {
        return toAdd;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getTaskID(toAdd)));
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

    }
```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert AddCommand.COMMAND_WORDS != null;

        return isCommandWord(AddCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"addtag"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
    public AddTagCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/AddTagCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert CheckCommand.COMMAND_WORDS != null;

        return isCommandWord(AddTagCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"check", "checked", "complete"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Mark task completion status to check/completed.\n"
            + "Example: " + DEFACTO_COMMAND + " 1\n"
            + "Parameters: INDEX (must be a positive integer)";

```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    protected CheckCommand () {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/CheckCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert CheckCommand.COMMAND_WORDS != null;

        return isCommandWord(CheckCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ClearCommand.java
``` java
/**
 * Clears the address book.
 */
public class ClearCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"clear"};
    public static final String MESSAGE_SUCCESS = "Task manager has been cleared!";

    /**
     * Creates and empty command with the relevant command words.
     */
    public ClearCommand() {
        super(COMMAND_WORDS);
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        model.resetData(new TaskManager());
        return new CommandResult(MESSAGE_SUCCESS);
    }

```
###### /java/seedu/task/logic/commands/ClearCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ClearCommand.COMMAND_WORDS != null;

        return isCommandWord(ClearCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/Command.java
``` java
/**
 * Represents a command with hidden internal logic and the ability to be executed.
 */
public abstract class Command {
    protected Model model;

    /**
     * Constructs the class with an array of valid command words.
     *
     * @param COMMAND_WORDS
     */
    public Command(String[] commandWords) {
        super();
    }

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of persons.
     *
     * @param displaySize used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForTaskListShownSummary(int displaySize) {
        return String.format(Messages.MESSAGE_TASKS_LISTED_OVERVIEW, displaySize);
    }

    /**
     * Executes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     * @throws CommandException If an error occurs during command execution.
     */
    public abstract CommandResult execute() throws CommandException;


    /**
     * Provides any needed dependencies to the command.
     * Commands making use of any of these should override this method to gain
     * access to the dependencies.
     */
    public void setData(Model model) {
        this.model = model;
    }

    /**
     * Checks if the provided command word belongs to this command.
     *
     * @param commmand
     * @return true if it is a command word, false if not.
     */
    protected static boolean isCommandWord(String[] commandWords, String command) {
        for (String i : commandWords) {
            if (i.equals(command)) {
                return true;
            }
        }
        return false;
    }

```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the task manager.
 */
public class DeleteCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"delete", "del", "remove", "-d"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + DEFACTO_COMMAND + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";

    public int targetIndex;

    /**
     *  Creates an empty delete command with the relevant commands words.
     *
     */
    protected DeleteCommand() {
        super(COMMAND_WORDS);
    }

    public DeleteCommand(int targetIndex) {
        this();
        this.targetIndex = targetIndex;
    }

```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert DeleteCommand.COMMAND_WORDS != null;

        return isCommandWord(DeleteCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"deltag"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
    public DeleteTagCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/DeleteTagCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert CheckCommand.COMMAND_WORDS != null;

        return isCommandWord(DeleteTagCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"edit", "change", "-e"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Edits the details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) [NAME] [from STARTDATE] [to ENDDATE] [tags]"
            + " ...\n"
            + "Example: " + DEFACTO_COMMAND + " 1 another task from tomorrow to next wednesday #first";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    private int filteredTaskListIndex;
    private EditTaskDescriptor editTaskDescriptor;

    public EditCommand() {
        super(COMMAND_WORDS);
    }

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        this();
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
    }

    /**
     * @return the editTaskDescriptor
     */
    public EditTaskDescriptor getEditTaskDescriptor() {
        return editTaskDescriptor;
    }

```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert EditCommand.COMMAND_WORDS != null;

        return isCommandWord(EditCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/EmailCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.logic.commands.exceptions.CommandException;

/**
 * @author amon
 *
 */
public class EmailCommand extends Command {
    public static final String[] COMMAND_WORDS = new String[] {"email"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_SUCCESS = "New email set successfully!";
    public static final String MESSAGE_INCORRECT = "Please specify a valid email!";

    private String email;

    public EmailCommand() {
        super(COMMAND_WORDS);
    }

    public EmailCommand(String email) {
        this();
        this.email = email;
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.commands.Command#execute()
     */
    @Override
    public CommandResult execute() throws CommandException {
        return new CommandResult(MESSAGE_SUCCESS);
    }

    public static boolean isCommandWord(String command) {
        return isCommandWord(EmailCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ExitCommand.java
``` java
/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"exit", "quit"};

    public static final String MESSAGE_EXIT_ACKNOWLEDGEMENT = "Exiting suru as requested ...";

    /**
     * Constructs a command with the relevant command words.
     */
    public ExitCommand() {
        super(COMMAND_WORDS);
    }

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
        return new CommandResult(MESSAGE_EXIT_ACKNOWLEDGEMENT);
    }

```
###### /java/seedu/task/logic/commands/ExitCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ExitCommand.COMMAND_WORDS != null;

        return isCommandWord(ExitCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"find", "search"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Finds all tasks whose names or tags contain "
            + "any of the specified keywords (case-insensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + DEFACTO_COMMAND + " tutorial lab assignment";

    private Set<String> keywords;
    private final Set<Tag> tagKeywords = new HashSet<>();

    /**
     * Constructs a command with the relevant command words.
     */
    private FindCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/FindCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert FindCommand.COMMAND_WORDS != null;

        return isCommandWord(FindCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"help"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Shows program usage instructions.\n"
            + "Example: " + DEFACTO_COMMAND;

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    /**
     * Constructs a command with the relevant command words.
     */
    public HelpCommand() {
        super(COMMAND_WORDS);
    }

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ShowHelpRequestEvent());
        return new CommandResult(SHOWING_HELP_MESSAGE);
    }

```
###### /java/seedu/task/logic/commands/HelpCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert HelpCommand.COMMAND_WORDS != null;

        return isCommandWord(HelpCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/IncorrectCommand.java
``` java
/**
 * Represents an incorrect command. Upon execution, throws a CommandException with feedback to the user.
 */
public class IncorrectCommand extends Command {

    public String feedbackToUser;

    /**
     * Constructs a command with no command words.
     */
    private IncorrectCommand() {
        super(new String[]{});
    }

    public IncorrectCommand(String feedbackToUser) {
        this();
        this.feedbackToUser = feedbackToUser;
    }

    @Override
    public CommandResult execute() throws CommandException {
        throw new CommandException(feedbackToUser);
    }

```
###### /java/seedu/task/logic/commands/IncorrectCommand.java
``` java
    public static boolean isCommandWord(String command) {
        return false;
    }
}

```
###### /java/seedu/task/logic/commands/ListCheckedCommand.java
``` java
    public static final String[] LIST_COMMAND_WORDS = new String[] {"checked"};
    public static final String DEFACTO_COMMAND = LIST_COMMAND_WORDS[0];

    public ListCheckedCommand() {
        super(LIST_COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/ListCheckedCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ListCheckedCommand.LIST_COMMAND_WORDS != null;

        return isCommandWord(ListCheckedCommand.LIST_COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ListCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"list"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_SUCCESS = "Listed all tasks";

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Lists all tasks with index numbers, "
            + "use checked or unchecked as keyword to only show checked or unchecked tasks\n"
            + "Parameters: [" + ListUncheckedCommand.DEFACTO_COMMAND + "][unchecked] \n"
            + "Example: " + DEFACTO_COMMAND + " " + ListUncheckedCommand.DEFACTO_COMMAND;

    public ListCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/ListCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ListCommand.COMMAND_WORDS != null;

        return isCommandWord(ListCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ListUncheckedCommand.java
``` java
    public static final String[] LIST_COMMAND_WORDS = new String[] {"unchecked"};
    public static final String DEFACTO_COMMAND = LIST_COMMAND_WORDS[0];

    public ListUncheckedCommand() {
        super(LIST_COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/ListUncheckedCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert ListUncheckedCommand.LIST_COMMAND_WORDS != null;

        return isCommandWord(ListUncheckedCommand.LIST_COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/LoadFromCommand.java
``` java

    public static final String[] COMMAND_WORDS = new String[] {"loadfrom", "load", "import"};

    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Defines a new load location for your tasks "
            + "Parameters: FILE_PATH"
            + "Example: " + DEFACTO_COMMAND
            + " ./taskmanager.xml";


    private LoadFromCommand() {
        super(COMMAND_WORDS);
    }

    public LoadFromCommand(String filepath) {
        this();
        this.setFilepath(filepath);
        registerAsAnEventHandler(this);
    }

```
###### /java/seedu/task/logic/commands/LoadFromCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert LoadFromCommand.COMMAND_WORDS != null;

        return isCommandWord(LoadFromCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"redo"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
    public RedoCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert RedoCommand.COMMAND_WORDS != null;

        return isCommandWord(RedoCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/ReminderCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.logic.commands.exceptions.CommandException;

public class ReminderCommand extends Command {
    public static final String[] COMMAND_WORDS = new String[] {"reminders"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_ENABLED = "Reminders have been enabled.";
    public static final String MESSAGE_DISABLED = "Reminders have been disabled.";
    public static final String MESSAGE_INCORRECT_ARGS = "Please specify whether to enable or disable reminders!";

    private boolean enabled;

    public ReminderCommand() {
        super(COMMAND_WORDS);
    }
    public ReminderCommand(boolean enabled) {
        this();
        this.enabled = enabled;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (enabled) {
            return new CommandResult(MESSAGE_ENABLED);
        }
        return new CommandResult(MESSAGE_DISABLED);
    }

    public static boolean isCommandWord(String command) {
        return isCommandWord(ReminderCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/SaveToCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"saveto", "save", "export"};

    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/SaveToCommand.java
``` java
    protected SaveToCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/SaveToCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert SaveToCommand.COMMAND_WORDS != null;

        return isCommandWord(SaveToCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/SelectCommand.java
``` java
/**
 * Selects a task identified using it's last displayed index from the task manager.
 */
public class SelectCommand extends Command {

    private int targetIndex;

    public static final String[] COMMAND_WORDS = new String[] {"select"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND
            + ": Selects the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + DEFACTO_COMMAND + " 1";

    public static final String MESSAGE_SELECT_TASK_SUCCESS = "Selected Task: %1$s";

    protected SelectCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/SelectCommand.java
``` java
    /**
     * @return the targetIndex
     */
    public int getTargetIndex() {
        return targetIndex;
    }

```
###### /java/seedu/task/logic/commands/SelectCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert SelectCommand.COMMAND_WORDS != null;

        return isCommandWord(SelectCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/SortCommand.java
``` java
// TODO: This class is unused and is not expected to be implemented for v0.5rc

public class SortCommand extends Command {

    public static final String[] COMMAND_WORDS = new String[] {"sort"};

    public SortCommand() {
        super(COMMAND_WORDS);
        throw new UnsupportedOperationException();
    }

    @Override
    public CommandResult execute() throws CommandException {
        // TODO Auto-generated method stub
        return null;
    }

```
###### /java/seedu/task/logic/commands/SortCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert SortCommand.COMMAND_WORDS != null;

        return isCommandWord(SortCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/TaskCompleted.java
``` java
    /**
     * Constructor to pass the valid command words back up to the base class.
     *
     * Protected access modifier is used to restrict access to the subclass.
     * @param COMMAND_WORDS
     */
    protected TaskCompleted(String[] COMMAND_WORDS) {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/UncheckCommand.java
``` java
public class UncheckCommand extends TaskCompleted {
    public static final String[] COMMAND_WORDS = new String[] {"uncheck", "incomplete"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

    public static final String MESSAGE_USAGE = DEFACTO_COMMAND + ": Mark task completion status "
            + "to unchecked/incompleted."
            + "\n"
            + "Example: " + DEFACTO_COMMAND + " 1\n"
            + "Parameters: INDEX (must be a positive integer)";

```
###### /java/seedu/task/logic/commands/UncheckCommand.java
``` java
    protected UncheckCommand() {
        super(COMMAND_WORDS);
    }

    //@@uauthor
    public UncheckCommand (int filteredTaskListIndex) {
        this();
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMarkComplete = lastShownList.get(filteredTaskListIndex);

        if (taskToMarkComplete.getCompletionStatus().getCompletion() == false) {
            throw new CommandException(String.format(MESSAGE_TASK_ALREADY_UNCHECKED, taskToMarkComplete.getName()));
        }

        Task completedTask = changeTaskCompletion(taskToMarkComplete);

        try {
            model.updateTask(filteredTaskListIndex, completedTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getTaskID(completedTask)));
        return new CommandResult(String.format(MESSAGE_UNCHECK_SUCCESS, taskToMarkComplete.getName()));
    }

```
###### /java/seedu/task/logic/commands/UncheckCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert UncheckCommand.COMMAND_WORDS != null;

        return isCommandWord(UncheckCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
    public static final String[] COMMAND_WORDS = new String[] {"undo"};
    public static final String DEFACTO_COMMAND = COMMAND_WORDS[0];

```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
    public UndoCommand() {
        super(COMMAND_WORDS);
    }

```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
    public static boolean isCommandWord(String command) {
        assert UndoCommand.COMMAND_WORDS != null;

        return isCommandWord(UndoCommand.COMMAND_WORDS, command);
    }
}
```
###### /java/seedu/task/logic/parser/AbstractParser.java
``` java
/**
 * @author amon
 *
 * Abstract class for all parsers to allow for easier registration of parsers.
 */
public abstract class AbstractParser {
    /** Parses the given string arguments into a command if valid.
     *
     * @param args
     * @return
     */
    public abstract Command parse(String args);

    /** Checks if the provided command word is a valid alias of the command.
     *
     * @param command
     * @return true if the word is a valid alias, false otherwise.
     */
    public abstract boolean isAcceptedCommand(String command);
}
```
###### /java/seedu/task/logic/parser/AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
/**
 * @author amon
 *
 */
public class AddCommandParser extends AbstractParser {

    private static final String PATTERN_MANDATORY_DESCRIPTION = "(?<description>.+?)";
    private static final String PATTERN_OPTIONAL_STARTDATE = "(?:\\s+(?:from|after|on)\\s+(?<startdate>.+?))?";
    private static final String PATTERN_OPTIONAL_ENDDATE = "(?:\\s+(?:to|by)\\s+(?<enddate>.+?))?";
    private static final String PATTERN_OPTIONAL_TAGS = "(?<tags>(?:\\s+#\\w+)+)?";
    private static final String ARGUMENTS_PATTERN = "^" + PATTERN_MANDATORY_DESCRIPTION + PATTERN_OPTIONAL_STARTDATE
            + PATTERN_OPTIONAL_ENDDATE + PATTERN_OPTIONAL_TAGS + "$";
    private static final String ARGUMENTS_PATTERN_QUOTED = "^" + PATTERN_MANDATORY_DESCRIPTION
            + PATTERN_OPTIONAL_STARTDATE + PATTERN_OPTIONAL_ENDDATE + PATTERN_OPTIONAL_TAGS + "$";
    private static final Pattern ARGUMENTS_FORMAT = Pattern.compile(ARGUMENTS_PATTERN, Pattern.CASE_INSENSITIVE);
    private static final Pattern ARGUMENTS_FORMAT_QUOTED = Pattern.compile(
            ARGUMENTS_PATTERN_QUOTED, Pattern.CASE_INSENSITIVE);

    private static final Logger logger = LogsCenter.getLogger(AddCommandParser.class);
    private static final String logPrefix = "[AddCommandParser]";

    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    @Override
    public Command parse(String args) {

        assert args != null;

        String taskName = null;
        String startDateString;
        String endDateString;
        String tagsString;
        Date startDate = null;
        Date endDate = null;

        Set<String> tagSet = new HashSet<String>();

        try {
            // Check for quoted task names
            if (args.length() > 0 && args.charAt(0) == '\'') {
                int nextIndex = args.indexOf('\'', 1);
                if (nextIndex > 0) {
                    taskName = args.substring(1, nextIndex);
                    args = args.substring(nextIndex);
                }
            }

            // Extract the tokens from the argument string using the appropriate pattern.
            Matcher matcher;
            if (taskName == null) {
                matcher = ARGUMENTS_FORMAT.matcher(args);
            }
            else {
                matcher = ARGUMENTS_FORMAT_QUOTED.matcher(args);
            }

            // Match on the processed arguments.
            if (!matcher.matches()) {
                throw new NoSuchElementException();
            }

            assert !args.isEmpty();

            // Extract the matcher groups
            if (taskName == null) {
                taskName = matcher.group("description");
            }

            startDateString = Optional.ofNullable(matcher.group("startdate")).orElse("");
            endDateString = Optional.ofNullable(matcher.group("enddate")).orElse("");
            tagsString = Optional.ofNullable(matcher.group("tags")).orElse("").trim();

            // Log tokens for debugging.
            logger.info(String.format("%s taskName: '%s', startDateString: '%s', endDateString: '%s', tags: '%s'",
                    logPrefix, taskName, startDateString, endDateString, tagsString));

            // Convert the String to Date objects
            startDate = NattyDateUtil.parseSingleDate(startDateString);
            endDate = NattyDateUtil.parseSingleDate(endDateString);

            // Remove the quotes if available
            taskName = taskName.charAt(0) == '\'' ? taskName.substring(1) : taskName;
            int lastIndex = taskName.length() - 1;
            taskName = taskName.charAt(lastIndex) == '\'' ? taskName.substring(0, lastIndex) : taskName;

            // Log the dates for debugging.
            if (startDate != null) {
                logger.info(String.format("%s startDate: %s", logPrefix, startDate.toString()));
            }
            if (endDate != null) {
                logger.info(String.format("%s endDate: %s", logPrefix, endDate.toString()));
            }

            // Add each tag to the tag set.
            tagSet = ParserUtil.parseTagStringToSet(tagsString);

            // Log the tags
            logger.info(String.format("%s tagSet: %s", logPrefix, tagSet.toString()));

            // Add the undo entry after successfully parsing an AddCommand
            UndoManager.pushUndoCommand(AddCommand.DEFACTO_COMMAND);

            return new AddCommand(
                    taskName,
                    startDate,
                    endDate,
                    false,
                    tagSet);
        } catch (NoSuchElementException nsee) {
            // TODO: This needs to be changed to the default case of search.
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return AddCommand.isCommandWord(command);
    }
}

```
###### /java/seedu/task/logic/parser/AddTagsParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return AddTagCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/CheckCommandParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return CheckCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/ClearCommandParser.java
``` java
public class ClearCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ClearCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ClearCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser extends AbstractParser {

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    @Override
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        // Add the undo entry after the DeleteCommand is successfully parsed.
        UndoManager.pushUndoCommand(DeleteCommand.DEFACTO_COMMAND);

        return new DeleteCommand(index.get());
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return DeleteCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/DeleteTagsParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return DeleteTagCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/EditCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser extends AbstractParser {

    private static final String PATTERN_MANDATORY_INDEX = "(?<index>[1-9]\\d*)";
    private static final String PATTERN_OPTIONAL_DESCRIPTION = "(?:\\s+(?<description>[^#]+?))?";
    private static final String PATTERN_OPTIONAL_STARTDATE = "(?:\\s+(?:from|after|on)\\s+(?<startdate>.+?))?";
    private static final String PATTERN_OPTIONAL_ENDDATE = "(?:\\s+(?:to|by)\\s+(?<enddate>.+?))?";
    private static final String PATTERN_OPTIONAL_TAGS = "(?<tags>(?:\\s+#\\w+)+)?";
    private static final String ARGUMENTS_PATTERN = "^" + PATTERN_MANDATORY_INDEX + PATTERN_OPTIONAL_DESCRIPTION
            + PATTERN_OPTIONAL_STARTDATE + PATTERN_OPTIONAL_ENDDATE + PATTERN_OPTIONAL_TAGS + "$";
    private static final String ARGUMENTS_PATTERN_QUOTED = "^" + PATTERN_MANDATORY_INDEX
            + PATTERN_OPTIONAL_STARTDATE + PATTERN_OPTIONAL_ENDDATE + PATTERN_OPTIONAL_TAGS + "$";

    private static final Pattern ARGUMENTS_FORMAT = Pattern.compile(ARGUMENTS_PATTERN, Pattern.CASE_INSENSITIVE);
    private static final Pattern ARGUMENTS_FORMAT_QUOTED = Pattern.compile(
            ARGUMENTS_PATTERN_QUOTED, Pattern.CASE_INSENSITIVE);

    private static final Logger logger = LogsCenter.getLogger(AddCommandParser.class);
    private static final String logPrefix = "[EditCommandParser]";

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        assert args != null;

        int index;
        String taskName = null;
        String startDateString;
        String endDateString;
        String tagsString;
        String argsToCheck = args;

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();


        try {
            // Check for quoted task names
            if (args.matches(".*'.*'")) {
                int firstIndex = args.indexOf('\'');
                int nextIndex = args.lastIndexOf('\'');
                taskName = args.substring(firstIndex + 1, nextIndex);

                // Remove the task name from the command
                argsToCheck = args.replace("'" + taskName + "'", "").trim();
            }

            logger.info(String.format("%s argsToCheck: '%s'", logPrefix, argsToCheck));

            // Extract the tokens from the argument string.
            Matcher matcher;
            if (taskName == null) {
                matcher = ARGUMENTS_FORMAT.matcher(argsToCheck);
            }
            else {
                matcher = ARGUMENTS_FORMAT_QUOTED.matcher(argsToCheck);
            }
            if (!matcher.matches()) {
                throw new NoSuchElementException();
            }

            // Extract the matcher groups
            if (taskName == null) {
                taskName = Optional.ofNullable(matcher.group("description")).orElse("").trim();
            }
            index = ParserUtil.parseIndex(matcher.group("index")).get();
            startDateString = Optional.ofNullable(matcher.group("startdate")).orElse("");
            endDateString = Optional.ofNullable(matcher.group("enddate")).orElse("");
            tagsString = Optional.ofNullable(matcher.group("tags")).orElse("").trim();

            // Remove the quotes if available
            if (!taskName.isEmpty()) {
                taskName = taskName.charAt(0) == '\'' ? taskName.substring(1) : taskName;
                int lastIndex = taskName.length() - 1;
                taskName = taskName.charAt(lastIndex) == '\'' ? taskName.substring(0, lastIndex) : taskName;
            }

            // Log tokens for debugging.
            logger.info(String.format("%s taskName: '%s', startDateString: '%s', endDateString: '%s', tags: '%s'",
                    logPrefix, taskName, startDateString, endDateString, tagsString));

            // Set the EditTaskDescriptor change values.
            if (!taskName.isEmpty()) {
                editTaskDescriptor.setName(ParserUtil.parseName(taskName));
            }
            editTaskDescriptor.setStartTime(ParserUtil.parseStartTime(startDateString));
            editTaskDescriptor.setEndTime(ParserUtil.parseEndTime(endDateString));
            editTaskDescriptor.setTags(ParserUtil.parseTagsForEdit(ParserUtil.parseTagStringToSet(tagsString)));

        } catch (NoSuchElementException nsee) {
            // TODO: This needs to be changed to the default case of search.
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }

        // Add the undo entry after successfully parsing an EditCommand.
        UndoManager.pushUndoCommand(EditCommand.DEFACTO_COMMAND);

        return new EditCommand(index, editTaskDescriptor);
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return EditCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/EmailCommandParser.java
``` java
package seedu.task.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.EmailCommand;
import seedu.task.logic.commands.IncorrectCommand;

/**
 * @author amon
 *
 */
public class EmailCommandParser extends AbstractParser {
    public static final String PATTERN_EMAIL_ADDRESS = "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@"
            + "((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]"
            + "\\.)+[a-zA-Z]{2,}))$";
    public static final Pattern ARGUMENTS_EMAIL = java.util.regex.Pattern.compile(PATTERN_EMAIL_ADDRESS);

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        String toMatch = args.trim();
        Matcher matcher = ARGUMENTS_EMAIL.matcher(toMatch);
        // TODO: Fix this
        if (matcher.matches() || !matcher.matches()) {
            return new EmailCommand(toMatch);
        }
        return new IncorrectCommand(EmailCommand.MESSAGE_INCORRECT);
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return EmailCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/ExitCommandParser.java
``` java
/**
 * @author amon
 *
 */
public class ExitCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ExitCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ExitCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/FindCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser extends AbstractParser {

    /**
     * Parses the given {@code String} of arguments in the context of the FindCommand
     * and returns an FindCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        // converts keywords to lower case to allow case-insensitive search
        for (String s: keywords) {
            s.toLowerCase();
        }
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    @Override
    public boolean isAcceptedCommand(String command) {
        return FindCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/HelpCommandParser.java
``` java
/**
 * @author amon
 *
 */
public class HelpCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new HelpCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return HelpCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListCheckedCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListCheckedCommand;

/**
 * @author amon
 *
 */
public class ListCheckedCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListCheckedCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListCheckedCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListCommandParser.java
``` java
    public ListCommandParser() {
        registeredParsers.add(new ListUncheckedCommandParser());
        registeredParsers.add(new ListCheckedCommandParser());
        registeredParsers.add(new ListFloatingCommandParser());
        registeredParsers.add(new ListDeadlineCommandParser());
        registeredParsers.add(new ListEventCommandParser());
        registeredParsers.add(new ListUpcomingCommandParser());
        registeredParsers.add(new ListOverdueCommandParser());
    }

    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns an istCommand/ListUncheckedCommand/ListCheckedCommand object for execution.
     */
    @Override
    public Command parse(String args) {

        // keywords delimited by whitespace
        final String keywords = args.trim();

        // if list is used without any keywords, return entire task list
        if (keywords.isEmpty()) {
            return new ListCommand();
        }

        // Run through the registered parsers and return the command if valid
        for (AbstractParser parser : registeredParsers) {
            if (parser.isAcceptedCommand(keywords)) {
                return parser.parse(keywords);
            }
        }

        // Return the incorrect command message if none matches.
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                ListCommand.MESSAGE_USAGE));
    }

```
###### /java/seedu/task/logic/parser/ListCommandParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListEventCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListEventCommand;

public class ListEventCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListEventCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListEventCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListFloatingCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListFloatingCommand;

/**
 * @author amon
 *
 */
public class ListFloatingCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListFloatingCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListFloatingCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListOverdueCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListOverdueCommand;

/**
 * @author amon
 *
 */
public class ListOverdueCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListOverdueCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListOverdueCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListUncheckedCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListUncheckedCommand;

/**
 * @author amon
 *
 */
public class ListUncheckedCommandParser extends AbstractParser {

    @Override
    public Command parse(String args) {
        return new ListUncheckedCommand();
    }

    @Override
    public boolean isAcceptedCommand(String command) {
        return ListUncheckedCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ListUpcomingCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.ListUpcomingCommand;

public class ListUpcomingCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new ListUpcomingCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ListUpcomingCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/LoadFromCommandParser.java
``` java

public class LoadFromCommandParser extends AbstractParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        return new LoadFromCommand(args);
    }

    @Override
    public boolean isAcceptedCommand(String command) {
        return LoadFromCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/Parser.java
``` java
/**
 * Parses user input.
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     * Allows for case insensitive matching.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)",
            Pattern.CASE_INSENSITIVE);

    private static final Logger logger = LogsCenter.getLogger(Parser.class);
    private static final String logPrefix = "[PARSER]";

    // Parsers are registered here as an AbstractParser ArrayList.
    private static final ArrayList<AbstractParser> registeredParsers = new ArrayList<AbstractParser>();

    public Parser() {
        /*
         *  Register the parsers individually on setup.
         *  The order of the parsers registered is important.
         */

        registeredParsers.add(new AddCommandParser());
        registeredParsers.add(new EditCommandParser());
        registeredParsers.add(new SelectCommandParser());
        registeredParsers.add(new DeleteCommandParser());
        registeredParsers.add(new ClearCommandParser());
        registeredParsers.add(new FindCommandParser());
        registeredParsers.add(new ListCommandParser());
        registeredParsers.add(new ExitCommandParser());
        registeredParsers.add(new HelpCommandParser());
        registeredParsers.add(new CheckCommandParser());
        registeredParsers.add(new UncheckCommandParser());
        registeredParsers.add(new UndoCommandParser());
        registeredParsers.add(new RedoCommandParser());
        registeredParsers.add(new SaveToCommandParser());
        registeredParsers.add(new LoadFromCommandParser());
        registeredParsers.add(new SortCommandParser());
        registeredParsers.add(new AddTagsParser());
        registeredParsers.add(new DeleteTagsParser());
        registeredParsers.add(new ReminderCommandParser());
        registeredParsers.add(new EmailCommandParser());
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        logger.info(logPrefix + " Raw User Input: '" + userInput + "'");

        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord").toLowerCase();
        final String arguments = matcher.group("arguments").trim();

        logger.info(logPrefix + " Command Word: '" + commandWord + "'");
        logger.info(logPrefix + " Arguments: '" + arguments + "'");

        // Run through the registered parsers and return the command if valid
        for (AbstractParser parser : registeredParsers) {
            if (parser.isAcceptedCommand(commandWord)) {
                return parser.parse(arguments);
            }
        }

        // Handle the default case.
        return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
    }
}
```
###### /java/seedu/task/logic/parser/ParserUtil.java
``` java
/**
 * Contains utility methods used for parsing strings in the various *Parser classes
 */
public class ParserUtil {

    private static final Pattern INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    /**
     * Returns the specified index in the {@code command} if it is a positive unsigned integer
     * Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<Integer> parseIndex(String command) {
        final Matcher matcher = INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty,
     * or if the list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

    /**
     * Splits a preamble string into ordered fields.
     * @return A list of size {@code numFields} where the ith element is the ith field value if specified in
     *         the input, {@code Optional.empty()} otherwise.
     */
    public static List<Optional<String>> splitPreamble(String preamble, int numFields) {
        return Arrays.stream(Arrays.copyOf(preamble.split("\\s+", numFields), numFields))
                .map(Optional::ofNullable)
                .collect(Collectors.toList());
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code String name} into a {@code Optional<Name>} if {@code name} is present.
     *
     * @param name
     * @return
     * @throws IllegalValueException
     */
    public static Optional<Name> parseName(String name) throws IllegalValueException {
        assert name != null;
        String tempName = name.equals("") ? null : name;
        return parseName(Optional.ofNullable(tempName));
    }

    /**
     * Parses a {@code Optional<String> completionStatus} into an
     * {@code Optional<CompletionStatus>} if {@code completionStatus} is present.
     */
    public static Optional<CompletionStatus> parseCompletionStatus(Optional<String> completionStatus)
            throws IllegalValueException {
        assert completionStatus != null;
        return completionStatus.isPresent() ?
                Optional.of(new CompletionStatus(Boolean.valueOf(completionStatus.get()))) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> startDate} into an {@code Optional<StartTime>} if {@code startDate} is present.
     */
    public static Optional<StartTime> parseStartTime(Optional<Date> startDate) throws IllegalValueException {
        assert startDate != null;
        return startDate.isPresent() ? Optional.of(new StartTime(startDate.get())) : Optional.empty();
    }

    /**
     * Parses a {@code String startDate} into an {@code Optional<StartTime>} if {@code startDate} is present.
     */
    public static Optional<StartTime> parseStartTime(String startDate) throws IllegalValueException {
        String processedDate = Optional.ofNullable(startDate).orElse("");
        Date parsedDate = NattyDateUtil.parseSingleDate(processedDate);
        return parseStartTime(Optional.ofNullable(parsedDate));
    }

    /**
     * Parses a {@code Optional<String> endDate} into an {@code Optional<EndTime>} if {@code endDate} is present.
     */
    public static Optional<EndTime> parseEndTime(Optional<Date> endDate) throws IllegalValueException {
        assert endDate != null;
        return endDate.isPresent() ? Optional.of(new EndTime(endDate.get())) : Optional.empty();
    }

    /**
     * Parses a {@code String endDate} into an {@code Optional<EndTime>} if {@code endDate} is present.
     */
    public static Optional<EndTime> parseEndTime(String endDate) throws IllegalValueException {
        String processedDate = Optional.ofNullable(endDate).orElse("");
        Date parsedDate = NattyDateUtil.parseSingleDate(processedDate);
        return parseEndTime(Optional.ofNullable(parsedDate));
    }

    /**
     * Parses {@code Collection<String> tags} into an {@code UniqueTagList}.
     */
    public static UniqueTagList parseTags(Collection<String> tags) throws IllegalValueException {
        assert tags != null;
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        return new UniqueTagList(tagSet);
    }

     /**
     * Parses {@code Collection<String> tags} into an {@code Optional<UniqueTagList>} if {@code tags} is non-empty.
     * If {@code tags} contain only one element which is an empty string, it will be parsed into a
     * {@code Optional<UniqueTagList>} containing zero tags.
     */
    public static Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

    /**
     * Split the tags string into a set.
     * Example: "#one #two" into ["one", "two"]
     *
     * @param tagsString
     * @return
     */
    public static Set<String> parseTagStringToSet(String tagsString) {
        Set<String> tagSet = new HashSet<String>();
        for (String i : tagsString.split("\\s+")) {
            if (i.length() > 1) {
                tagSet.add(i.substring(1));
            }
        }
        return tagSet;
    }
}
```
###### /java/seedu/task/logic/parser/RedoCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.RedoCommand;

/**
 * @author amon
 *
 */
public class RedoCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new RedoCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return RedoCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/ReminderCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.ReminderCommand;

/**
 * @author amon
 *
 */
public class ReminderCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        String option = args.trim().toLowerCase();
        if (option.equals("enable")) {
            return new ReminderCommand(true);
        } else if (args.equals("disable")) {
            return new ReminderCommand(false);
        }
        return new IncorrectCommand(ReminderCommand.MESSAGE_INCORRECT_ARGS);
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return ReminderCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/logic/parser/SaveToCommandParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return SaveToCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/SelectCommandParser.java
``` java
/**
 * Parses input arguments and creates a new SelectCommand object
 */
public class SelectCommandParser extends AbstractParser {

    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return SelectCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/SortCommandParser.java
``` java

public class SortCommandParser  extends AbstractParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    @Override
    public Command parse(String args) {
        return new SortCommand();
    }

    @Override
    public boolean isAcceptedCommand(String command) {
        return SortCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/UncheckCommandParser.java
``` java
    @Override
    public boolean isAcceptedCommand(String command) {
        return UncheckCommand.isCommandWord(command);
    }
}
```
###### /java/seedu/task/logic/parser/UndoCommandParser.java
``` java
package seedu.task.logic.parser;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.UndoCommand;

/**
 * @author amon
 *
 */
public class UndoCommandParser extends AbstractParser {

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#parse(java.lang.String)
     */
    @Override
    public Command parse(String args) {
        return new UndoCommand();
    }

    /* (non-Javadoc)
     * @see seedu.task.logic.parser.AbstractParser#isAcceptedCommand(java.lang.String)
     */
    @Override
    public boolean isAcceptedCommand(String command) {
        return UndoCommand.isCommandWord(command);
    }

}
```
###### /java/seedu/task/model/task/StartTime.java
``` java
/**
 * Represents a task's start time in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidTime(String)}
 */
public class StartTime {

    public static final String MESSAGE_TIME_CONSTRAINTS = ""; // Validation on string no longer necessary in model.

    public final Date value;

    /**
     * @return the value
     */
    public Date getValue() {
        return value;
    }

    /**
     * Validates given start time.
     *
     * @throws IllegalValueException if given time string is invalid.
     */
    public StartTime(Date startTime) throws IllegalValueException {
        if (!isValidTime(startTime)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        this.value = startTime;
    }

    /**
     * Returns true if a given string is a valid task start time.
     */
    public static boolean isValidTime(Date test) {
        //return (test.matches(TIME_VALIDATION_REGEX) || test.matches(EMPTY_TIME_VALIDATION_REGEX));
        return true;
    }

```
